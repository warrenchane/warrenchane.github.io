<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>spring-cloud实践</title>
      <link href="/22420.html"/>
      <url>/22420.html</url>
      
        <content type="html"><![CDATA[<h1 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h1><ul><li><input checked="" disabled="" type="checkbox"> spring 版本概念与选择</li><li><input checked="" disabled="" type="checkbox"> spring-cloud-kubernetes 注册与发现</li><li><input checked="" disabled="" type="checkbox"> openFeign实现伪RPC远程调用</li><li><input disabled="" type="checkbox"> robbin</li><li><input disabled="" type="checkbox"> 日志追踪</li></ul><h1 id="spring-cloud-版本"><a href="#spring-cloud-版本" class="headerlink" title="spring cloud 版本"></a>spring cloud 版本</h1><p><img src="https://blog-1254114069.cos.ap-beijing.myqcloud.com/blog/2020/02/23/15824464326002.jpg" alt=""><br><img src="https://blog-1254114069.cos.ap-beijing.myqcloud.com/blog/2020/02/23/15824464665431.jpg" alt=""></p><h1 id="spring-cloud-kubernetes"><a href="#spring-cloud-kubernetes" class="headerlink" title="spring-cloud-kubernetes"></a>spring-cloud-kubernetes</h1><p>spring-cloud的注册中心是Eureka，服务发现是通过将服务注册到注册中心后，各个服务连接注册中心，从注册中心定时获取服务列表及服务地址来实现的。</p><p>在k8s中，所有的service以及pod信息都会存入etcd中，相当于etc就扮演了注册中心的角色，并且在k8s中能通过CoreDNS完成通过服务名+端口的形式让各个服务之间相互通信，cloud在集成k8s的时候就可以使用k8s的注册中心来实现服务注册与服务发现。<br>SpringCloud Kubernetes 这个组件的服务发现目的就是获取上面所述的 Kubernetes 中一个或者多个 Namespace 下的所有 服务列表，且在过滤列表时候设置过滤的 端口号 ，这样获取到服务列表后就能让依赖它们的 SpringBoot 或者其它框架的应用完成服务发现工作，让服务能够通过 <code>http://ServiceName:Port</code> 这种方式进行访问。<br>集成的方式也特别简单，只要在pom文件中引入组件<code>spring-cloud-starter-kubernetes-all</code>即可。</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-kubernetes-all<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h1 id="spring-cloud-openfeign"><a href="#spring-cloud-openfeign" class="headerlink" title="spring cloud openfeign"></a>spring cloud openfeign</h1><p>我们在进行微服务体系建设中，服务拆分带来的好处是通过将服务进行细颗粒度的拆分使得服务的职责更加单一，服务的体系更为清晰。但是缺点是会带来一定程度的代码量的增加，增加的部分在于远程调用。<br>举个例子说明，如下图所示：<br><img src="https://blog-1254114069.cos.ap-beijing.myqcloud.com/blog/2020/02/23/15824449257394.jpg" alt=""></p><p>对于同样的业务来说，原本是一个项目，只不过因为职责的问题，分为了三个模块，对于开发来说，在一个项目中，不同的模块之间的通信就是本地方法的调用。这时候我们进行了服务拆分，使得原有的一个项目变为了三个项目，其中B和C是底层项目，A为上层项目，这时A调用B和C的接口就是远程通信，那么在A中就要声明http客户端，以及各个接口的参数以及返回值的POJO定义，这是额外增加的代码工作量，我们希望的是，在项目A中调用B和C服务就像是调用本地接口一样。<br>RPC 是好的解决方案，不过这里我想说的是另外一种解决方案，通过openfeign实现伪RPC的形式来达到我们的目的。</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>使用示例：<br>在api类中定义参数对象、方法、返回值对象：<br><img src="https://blog-1254114069.cos.ap-beijing.myqcloud.com/blog/2020/02/23/15824453160804.jpg" alt=""><br>然后在实现类中实现该接口：<br><img src="https://blog-1254114069.cos.ap-beijing.myqcloud.com/blog/2020/02/23/15824453589092.jpg" alt=""><br>最后在调用方处声明该客户端：<br><img src="https://blog-1254114069.cos.ap-beijing.myqcloud.com/blog/2020/02/23/15824454406096.jpg" alt=""><br>声明的时候，使用<code>@FeignClient</code>注解，里面有两个重要的参数，<code>name</code>参数是服务的名称，这个name用于进行服务发现，我们的服务在启动的时候会把自己的名字注册到注册中心去，在使用的时候通过该名字可以发现服务的信息与地址。<code>url</code>参数是指明服务的地址，优先级高于服务发现得到的服务地址。<br><code>url</code>参数可用于本地环境的调试，大家可以看到图中，<code>url="$(eureka-feign-client.url)"</code>这种形式的话，可以从配置文件中获取url的地址，很方便就可以区分生产环境、测试环境以及本地开发环境。<br>最后是使用，如下图所示：<br><img src="https://blog-1254114069.cos.ap-beijing.myqcloud.com/blog/2020/02/23/15824454589523.jpg" alt=""></p><p>通过这种方式，我们在调用远程服务的时候，就相当于在调用本地的方法一样，能够大大节省调用者的开发工作量。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://juejin.im/entry/5b7a663fe51d4538e6331274" target="_blank" rel="noopener">译：使用 Kubernetes、Spring Boot 2.0 和 Docker 的微服务快速指南 | Spring For All - 后端 - 掘金</a></li><li><a href="http://www.xifan.me/post/how-to-local-debugging-with-spring-cloud-on-kubernetes/" target="_blank" rel="noopener">【笔记】对于部署在Kubernetes里的Spring Cloud，如何进行本地调试？ - xifan - a blog</a></li><li><a href="https://blog.csdn.net/u013360850/article/details/100635405" target="_blank" rel="noopener">(3条消息)Spring Cloud 使用 Kubernetes 作为注册中心_HelloWood-CSDN博客</a></li><li><a href="http://www.mydlq.club/article/33/" target="_blank" rel="noopener">Kubernetes 开发 SpringCloud (一)、使用SpringCloud Kubernetes组件进行服务发现 · 小豆丁个人博客</a></li><li><a href="http://www.itmuch.com/spring-cloud-sum/feign-multiple-params/" target="_blank" rel="noopener">如何使用Feign构造多参数的请求 | 周立的博客 - 关注Spring Cloud、Docker</a></li><li><a href="https://github.com/spring-cloud/spring-cloud-kubernetes" target="_blank" rel="noopener">spring-cloud/spring-cloud-kubernetes: Kubernetes integration with Spring Cloud Discovery Client, Configuration, etc…</a></li><li><a href="https://www.zuojl.com/define-maven-archetype/" target="_blank" rel="noopener">自定义 Maven Archetype 模板</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>直播技术</title>
      <link href="/22673.html"/>
      <url>/22673.html</url>
      
        <content type="html"><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/23090320" target="_blank" rel="noopener">关于直播，所有的技术细节都在这里了（一） - 知乎</a><br><a href="https://github.com/f2e-journey/xueqianban/issues/61" target="_blank" rel="noopener">视频直播的技术原理和实现思路方案整理 · Issue #61 · f2e-journey/xueqianban</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&amp;mid=2653578065&amp;idx=1&amp;sn=1da088b11c797d2be7b5f7afb8f056bb&amp;chksm=84b3b156b3c438401715dc40f7791010b11050983a67fa533a4b559cb67ea6d0ce1996970481&amp;scene=4#wechat_redirect" target="_blank" rel="noopener">从0到1打造直播 App</a><br><a href="https://github.com/Tinywan/html5-dash-hls-rtmp" target="_blank" rel="noopener">Tinywan/html5-dash-hls-rtmp: HTML5播放器、M3U8直播/点播、RTMP直播、低延迟、推流/播流地址鉴权</a><br>WebRTC</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="https://blog-1254114069.cos.ap-beijing.myqcloud.com/blog/2020/02/05/15808805759846.jpg" alt=""><br>主播端是产生视频流的源头，由一系列的流程组成：</p><ol><li>通过一定的设备采集数据</li><li>将采集的这些视频进行一系列处理，比如水印、美颜和特效滤镜</li><li>将处理后的结果视频编码压缩成可观看可传输的视频流</li><li>分发推流，将压缩后的视频流通过网络通道传输出去</li></ol><p>播放端</p><ul><li>秒开</li><li>实时</li><li>互动</li></ul><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p><img src="https://blog-1254114069.cos.ap-beijing.myqcloud.com/blog/2020/02/05/15808808928607.jpg" alt=""><br>直播整体流程流程如下所示：</p><blockquote><p>录制 -&gt; 编码 -&gt; 网络传输 -&gt; 解码 -&gt; 播放</p></blockquote><p>WebRTC</p><p>技术点如下：</p><blockquote><ol><li>怎样录制视频</li><li>怎样实时上传直播视频</li><li>怎样播放直播视频</li><li>直播间的用户如何交互</li></ol></blockquote><p>关于交互的话，比较简单，用websocket就可以了，关键的技术难点在于视频流的上传与下发。</p><p>完整的直播包括如下：</p><ol><li>视频端录制</li><li>视频播放端</li><li>流媒体服务器端</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>learning-selenium</title>
      <link href="/34939.html"/>
      <url>/34939.html</url>
      
        <content type="html"><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://selenium-python-zh.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">Selenium with Python中文翻译文档 — Selenium-Python中文文档 2 documentation</a><br><img src="https://blog-1254114069.cos.ap-beijing.myqcloud.com/blog/2020/02/04/15808069739256.jpg" alt=""><br><img src="https://blog-1254114069.cos.ap-beijing.myqcloud.com/blog/2020/02/04/15808069916503.jpg" alt=""></p><h1 id="selenium-学习"><a href="#selenium-学习" class="headerlink" title="selenium 学习"></a>selenium 学习</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><h2 id="用来做什么"><a href="#用来做什么" class="headerlink" title="用来做什么"></a>用来做什么</h2><h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>自动化测试之路</title>
      <link href="/29471.html"/>
      <url>/29471.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是自动化测试"><a href="#什么是自动化测试" class="headerlink" title="什么是自动化测试"></a>什么是自动化测试</h1><h1 id="为什么要做自动化测试"><a href="#为什么要做自动化测试" class="headerlink" title="为什么要做自动化测试"></a>为什么要做自动化测试</h1><h1 id="如何做自动化测试"><a href="#如何做自动化测试" class="headerlink" title="如何做自动化测试"></a>如何做自动化测试</h1><blockquote><p>接口测试<br>造数据<br>前端页面自动化<br>逻辑自动化</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>web-开发最佳实践</title>
      <link href="/42412.html"/>
      <url>/42412.html</url>
      
        <content type="html"><![CDATA[<h1 id="Cookies-与-Session"><a href="#Cookies-与-Session" class="headerlink" title="Cookies 与 Session"></a>Cookies 与 Session</h1><blockquote><p>当请求成功以后，服务端会告诉客户端设置哪些Cookies信息，在后续访问页面时，客户端把Cookies信息传递给服务端。</p></blockquote><p>由于http协议是无状态的协议，为了能够记住请求的状态，于是引入了Session和Cookie的机制，session是存在于服务器端的，在单体式应用中，他是由Tomcat管理的，存在于tomcat的内存中，当我们为了解决分布式场景中的session共享问题时，引入了redis，其共享内存，以及支持key自动过期的特性，非常契合session的特性。</p><p>当然session的存储介质也可以是mysql或者mongo</p><p>而cookie是存在客户端的，或者说存储在浏览器的。cookie并不常用。有一类特殊的Cookie却是我们需要额外关注的，那便是与session相关的sessionId，他是真正维系客户端和服务端的桥梁。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>投机备忘录</title>
      <link href="/38601.html"/>
      <url>/38601.html</url>
      
        <content type="html"><![CDATA[<h1 id="历史学是未来学"><a href="#历史学是未来学" class="headerlink" title="历史学是未来学"></a>历史学是未来学</h1><blockquote><p>只有知道过去，才能洞见未来。<br>只有把握大趋势，才能得到大回报。</p></blockquote><h1 id="2019年"><a href="#2019年" class="headerlink" title="2019年"></a>2019年</h1><h2 id="中美贸易战"><a href="#中美贸易战" class="headerlink" title="中美贸易战"></a>中美贸易战</h2><blockquote><p>贸易战，中国与美国掐架，中国打击的是美国的农产品，所有与美国出口相关的农产品都会上涨，比如说：豆粕，大豆，菜粕。底层逻辑是，供给侧，供给变少然后价格就会上涨。</p></blockquote><h2 id="猪瘟"><a href="#猪瘟" class="headerlink" title="猪瘟"></a>猪瘟</h2><blockquote><p>猪瘟导致猪肉价格上涨，这轮周期为期一年，与猪相关的上游供给，比如说豆粕，大豆会先下跌，后上涨。因为猪瘟到来，猪开始会变少，消耗的饲料会减少，然后猪价上涨，养猪的人会增多，猪的数量也会增多，猪的饲料也会增多，这就是周期的魅力。</p></blockquote><h2 id="伊朗与美国开撕"><a href="#伊朗与美国开撕" class="headerlink" title="伊朗与美国开撕"></a>伊朗与美国开撕</h2><blockquote><p>原油期货上涨，原因是，伊朗是原油出口大国，一旦美国对其进行经济封锁，势必导致原油供给变少，还有战争所带来的恐慌情绪</p></blockquote><h1 id="2020年"><a href="#2020年" class="headerlink" title="2020年"></a>2020年</h1><h2 id="武汉冠状病毒传染病"><a href="#武汉冠状病毒传染病" class="headerlink" title="武汉冠状病毒传染病"></a>武汉冠状病毒传染病</h2><blockquote><p>春节档爆冷，因为大家都害怕传染，不敢去看电影，所以票房肯定会爆冷。<br>欢喜传媒与字节跳动战略合作，将《囧妈》卖给了头条系，这可能是一个新的机会，加速影视传媒ToC转型的进程。</p></blockquote><blockquote><p>鸡蛋期货下跌：武汉的冠状病毒是因为野生动物，禽类会被列入名单，相应的鸡蛋会出现恐慌情绪，大家会避免去吃鸡蛋或者鸡鸭鹅这类禽类，所以鸡蛋期货会下跌。</p></blockquote><blockquote><p>2月3号，股市开盘，医药股大涨，其他股份大跌，期货市场普遍大跌，跌基本都是跌停。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的读书方法论</title>
      <link href="/42527.html"/>
      <url>/42527.html</url>
      
        <content type="html"><![CDATA[<ul><li>做摘录</li><li>写感悟</li><li>写读书笔记的时候要这样写：<ul><li>读完一本书以后，用一段话讲一下作者的背景以及人生经历，用几段话写一下作者在书中最想阐述的一个到三个观点。</li><li>在每段摘录上面，附上自己的点评</li></ul></li><li>与人交流</li><li>不仅要移动而且要联通</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>传媒行业投资备忘录</title>
      <link href="/55714.html"/>
      <url>/55714.html</url>
      
        <content type="html"><![CDATA[<h3 id="2B-to-2C-转换"><a href="#2B-to-2C-转换" class="headerlink" title="2B to 2C 转换"></a>2B to 2C 转换</h3><blockquote><p>在慈文传媒副总裁、首席品牌官赵斌看来，随着视频网站用户数量的继续增加，商业模式一定会更快地从2B向2C转化，未来话语权很可能既不在电视台、也不在视频网站，而在市场群体的共同选择倾向上：“过去制作公司与电视台、视频网站的甲方乙方‘你我关系’，已变为共同面向市场群体的‘我们关系’。三者应该建立利益共享机制，一起做蛋糕，然后分蛋糕，而不再是各做各的蛋糕。”</p></blockquote><p>2014年，慈文传媒打响IP第一枪，but，现在已经不仅仅是IP为王的时代了，fbb事件以后，传媒行业面临洗牌，资源重新整合，中国一定会催生出像奈飞这样的大公司，电视剧行业也会有HBO这样的牛逼公司。</p><p>从2B到2C的转换是慈文传媒结合当前互联网形式下提出的概念，这种模式的转换能不能成功，有待验证。<br>不过电视台的市场份额一步步地被视频网站所侵蚀，现在国内视频网站是爱优腾占主导地位，将来的影视传媒行业到底谁是主导地位不好说，有的观点是平台占大头，有的观点是内容生产商占大头，不过我的观点是，即便是内容生产商占大头，平台也不会吃亏，毕竟平台可不是哪个公司都能做的。</p><h3 id="关于剧集开发进度变缓"><a href="#关于剧集开发进度变缓" class="headerlink" title="关于剧集开发进度变缓"></a>关于剧集开发进度变缓</h3><p>头部电视剧公司项目储备减少，除了成本、周期等因素，或许也与过去两三个月来的影视行业税务大震荡有关。此前曾有电影公司高管披露，在新税制下，由于成本大增，制作公司目前已经叫停了至少70部影视作品，包括30套电视剧以及40余部电影，对影视圈影响极大。<br>在这个播出渠道更替，舆论风向不明的时期，很多公司放慢了剧集开发的进度。慈文影视曾在年初宣布拍摄《脱骨香》《弹痕》《寻找爱情的邹小姐》等剧，但直到现在开拍的只有《风暴舞》。从这个角度来看，放慢拍摄是为了规避风险。</p><h3 id="关于影视寒冬"><a href="#关于影视寒冬" class="headerlink" title="关于影视寒冬"></a>关于影视寒冬</h3><p>影视“寒冬”之说已成行业共识，一二级市场缺钱的大背景下，BAT们的大手笔让行业艳羡，高价“嫁入豪门”的新丽传媒更是令市场咋舌。不管外界环境如何，继续留在这个行业的总得凭着一股信念走下去。曾经，许多人心中的这个信念是赚快钱，现在潮水退去，真正精耕细作的作品能在如今的市场上获得赏识。</p><p>整个中国电影市场一度出现疑似“拐点”，在这个池子里分一杯羹，越来越考验片方在内容和发行各个环节的把控。在传统的电视台渠道衰微的同时，内容方们开始更加密切地和视频平台合作，影视公司们纷纷加码互联网内容。</p><h3 id="关于监管"><a href="#关于监管" class="headerlink" title="关于监管"></a>关于监管</h3><p>而“监管风险”已不再是一句例行的风险警示，正在成为所有内容生产者、内容平台要注意的首要问题之一。</p><p>华策影视依靠“大工业化量产”策略，2018年1~8月华策有10部“全网剧”实现首播。</p><p>与慈文传媒类似，欢瑞世纪、唐德影视、唐人影视上半年在剧集市场上都出现了或多或少的哑火。而其背后原因或许正与一则“限古令”有关。</p><p>完美世界在上半年影视业务上取得了93.85%的高增长，但游戏业务却出现了下滑，报告期内，公司游戏业务实现营收26.63亿元，同比下滑13.26%；慈文传媒在游戏业务方面实现营收1.68亿元，同比下滑20.91%。虽然两者下滑原因有所差异，但是随着国家网游政策的出台，游戏业务在未来或许很难出现如从前一般的高收入了。</p><p>现在强监管的是台播，而不是网播，现在的影视剧都挖空心思服务于台播，但是我敢断言在不久的将来，网播市场就被完全打开，同时前几年的监管不会过严，这样的形势下一定能催生出一家稍微牛逼一点的公司，而脱颖而出的一定是内容过硬同时资源丰富的公司。</p><p>有数据显示，电视剧观众中，通常女性占比高达69%；网络端女性用户视频的用户也高达53.8%。可以说，如何更好地服务女性观众，吸引女性观众或用户，是影视制作公司一直关注的重要方向。</p><p>一个游戏赚钱的游戏一定是女性用户占比不低的公司，一般来说女性消费比较非理性，同时由于荷尔蒙的带动，一般在游戏中男性是秀肌肉的一方。</p><p>严歌苓说：“如今碎片化阅读已经成为时代主流，文学作品的影视化，将使作品更加具象，更易被大众所接受”。</p><p>所有的亏损，都是源于缺乏实力，阿里影业背后有阿里巴巴，可以持续亏钱，A股中那些没有爸爸的公司，一有稍微的亏损或者盈利不及预期，股价就稀里哗啦往下跌。</p><h3 id="关于首轮发行收入，二轮发行收入"><a href="#关于首轮发行收入，二轮发行收入" class="headerlink" title="关于首轮发行收入，二轮发行收入"></a>关于首轮发行收入，二轮发行收入</h3><p><strong>对于电视剧公司，什么是首轮发行收入，二轮播出还会有收入吗？</strong></p><p>在电视播映权的转让中，包括首轮发行和二轮发行及多轮发行。<br>首轮发行一般在24个月的时间内采用“地面频道+首轮卫星频道+次首轮卫星频道”的形式基本能够实现全部发行收入。<br>二轮发行及多轮发行是指在首轮发行完成期满后的再发行，由于二轮和多轮发行的发行时间比较滞后，因此二轮和多轮发行与首轮相比收入会下降很多。<br>对于一般的作品来说首轮发行收入基本上是所有的收入，二轮发行和爆款一样可遇不可求，而且二轮发行的收入比例往往较低。</p><h3 id="IP变现形式"><a href="#IP变现形式" class="headerlink" title="IP变现形式"></a>IP变现形式</h3><p>网文——阅文集团<br>影视剧<br>游戏——慈文传媒（赞成科技），当年花千骨带来的收入为4亿，其中影视剧方面是1亿，游戏及其它利润为3亿（大部分来自游戏）<br>有声书——喜马拉雅模式</p><h2 id="影视行业收入成本核算"><a href="#影视行业收入成本核算" class="headerlink" title="影视行业收入成本核算"></a>影视行业收入成本核算</h2><p><a href="http://birdbrokers.com/2017/01/how-to-calculate-the-revenue-and-cost-of-the-film.html" target="_blank" rel="noopener">电影行业收入成本如何核算？ – 菜鸟财经</a><br>根据《电影企业会计核算办法》，对于存在跨期销售情况的影视制作企业在结转各期的销售成本时，可结合自身情况适当选择“计划收入比例法”、“零毛利率法”和“固定比例法”中的任何一种。</p><ol><li>零毛利法，就是按照应结转销售成本额与实际取得的销售收入额相等，使其毛利为零的一种销售成本结转方法。很显然，该方法的选用虽然可以满足会计核算的谨慎性需求，但对配比性原则的遵循则是十分欠缺的，不仅影响了会计信息的质量，也影响了各期经营成果的可比性，不利于报表使用各方对于企业盈利能力变化的全面客观评价。</li><li>固定比例法，则是以一个固定比例作为计算各期应结转销售成本依据的一种方法。这种该方法的弊端的是固定比例到底选用多少合适，如果选用不适当，不仅在配比性的问题上不能得到充分有效地解决，而且还有可能影响到谨慎性原则的遵循。</li><li>计划收入比例法：<br>该方法是指企业从首次确认销售收入之日起，在成本配比期内，以当前已经实现的销售收入占计划收入的比例为权数，计算确定本期应结转的相应销售成本。<br>计算公式为：<br>$$ 计划销售成本率 ＝ \dfrac{影视剧入库的实际总成本}{预计影视剧成本配比期内的销售收入总额}×100％$$<br>$$ 本期（月）应结转销售成本额＝本期（月）影视剧销售收入额×计划销售成本率$$<br>用通俗的一句话来说就是，收了多少钱则算多少当期结转成本。<br>在影视剧成本配比期内，因为客观原因或者企业判断失误，预期收入与实际收入严重偏离的情况时，企业应该及时作出重新预测，依据现实实际情况调整影视剧成本配比期内的预计销售收入总额，使预测收入的方法更科学，结果更准确。<br>该方法的三要素：实际入库总成本、当期已确认的销售收入以及预期销售收入总额，其中前两项是比较容易做到准确计量的，问题的核心在于公司是否能使影视剧的预计销售总收入尽可能接近实际结果，从而根据已确认的收入占预计销售总收入的比例结转成本，保证收入确认与成本结转的匹配和准确。</li></ol><p>下面讲一下公司在实际操作中保证预测收入准确性的措施和方法，因为电影和电视剧的销售模式有差异，所以分开讲。</p><h3 id="电影项目预期收入的测算依据"><a href="#电影项目预期收入的测算依据" class="headerlink" title="电影项目预期收入的测算依据"></a>电影项目预期收入的测算依据</h3><ul><li>电影销售的收入构成</li></ul><p>电影项目的收入 = 电影票房收入 + 其他收入<br>其他收入 = 海外发行收入 + 音像版权收入 + 电视、航空及网络播映权收入</p><p>电影票房分账收入：在电影片完成摄制并经电影电视行政主管部门审查通过取得《电影片公映许可证》，电影片于院线、影院上映后按双方确认的实际票房统计及相应的分账方法所计算的金额确认；<br>电影版权收入：在影片取得《电影片公映许可证》、母带已经交付，且交易相关的经济利益很可能流入本公司时确认。</p><p>其中，电影票房收入一般占电影收入的80%以上，其他收入占比较低。主要原因是：国产电影的国际化运作水平不足，国际影响力和市场知名度有限。<br><font color="red">不过着重说明的一点是：由于乐视以及爱优腾的入场，付费版权的概念已经被大众所接受，这块的收入占比在将来会越来越高，甚至于出现大规模的精致网络电影，这块当做一个待确认问题：网络电影收入成本核算？</font><br>目前来说，电影票房收入是电影收入的决定性因素，因此公司对电影项目的收入的预测主要是对电影票房收入的预测。</p><ul><li>电影项目收入的预测</li></ul><p>一般情况下，在电影公映后的会计期末，国内票房收入的确认是根据院线发给公司的票房结算单来统计的。通常影片当日票房收入由院线统计后于次日传真给公司，院线与公司在影片放映后<code>每月就票房分账结算一次</code>。其他收入中，版权销售一般在影片上映5周内基本签约或者谈定价格。</p><p>电影票房的主要档期通常仅仅为3~5周，基本可以实现90%以上甚至于100%的票房收入。</p><p>会计报告的编报一般会在报告期后一个月内完成，在此期间内，即使电影的上映存在跨期的情况，但实际上在会计报表出具日也已基本放映结束。现在来讲，基本上电影收入无需预测，用猫眼一看就知道某部电影的票房几何了！</p><p>举个实例，公司电影上映期票房收入时间进度如下表所示：<br><img src="https://blog-1257857643.cos.ap-beijing.myqcloud.com/blog/15399220475902.png" alt=""></p><h3 id="电视剧项目预期收入的测试依据"><a href="#电视剧项目预期收入的测试依据" class="headerlink" title="电视剧项目预期收入的测试依据"></a>电视剧项目预期收入的测试依据</h3><ul><li>电视剧项目的收入构成</li></ul><p>销售收入包括电视播映权转让收入、音像版权收入、网络播映权收入等。<br>电视播映权的转让中，还包括首轮播映权转让和二轮播映权转让。<br>首轮播映权是部分电视台可以按约定的顺序在2年内（部分剧目延长到3~5年）先后开始播放的权利；<br>二轮播映权是指在首轮播放结束后，其他部分电视台继续播放的权利。<br>由于二轮播映权在播放时间上要滞后较多，观众接受度不高，因此二轮播映权的销售价格远远低于首轮播映权，一般来说是首轮的10%以下……<br>but，现在网播做得风生水起，网播的体量已经远远超过台播，现在一般来讲大IP网播收入比台播高得多。<br>这里要说到上面讲得2B到2C的转换，影视剧台播只可能是2B的模式，内容制作公司是供应商，电视台是经销商，网播既可以是传统的2B模式，也可以将C端打开，由C端用户来决定是否为正在观看的电视剧付费，而不是网播平台统一决定某某电视剧是VIP可以观看的。</p><ul><li>电视剧项目的收入预测</li></ul><p>一般在电视剧的拍摄和制作过程中，基于项目投资规模、演职人员市场号召力、剧本创作等构成电视剧成本、质量的核心要素已基本确定，故此时公司就已开始与客户进行电视剧产品的询价和沟通，并得到初步的价格信息，销售人员及时将此价格信息反馈至制片部门，如果反馈价格过低，制片部门会通过调整演职人员、故事主线、制作费用等及时降低电视剧的制作成本规避未来售价过低的市场风险。由此公司的制作成本预算是在充分考虑未来市场销售价格的基础上制定的，公司将电视剧的制作成本加上合理比例的毛利作为预计的销售总价格，是基于市场合理预期的价格。</p><p>由于存在合理的市场预期价格，公司制定的销售计划，是以实现销售总价为目标，统筹安排下的一揽子销售计划，具体而言是将全国各省级地面电视频道和各卫星频道作为目标销售客户，在与客户充分地接触与沟通后，获取不同客户的报价信息，而后灵活采用不同的销售模式，在满足客户需求的同时实现利润的最大化。<br>首轮播映权的交易中，一般由地面频道加上星频道的合约来组成，地面不超过30 家，按照国家广电总局的规定同时上星的频道不能超过4 家。</p><p>$$ 电视剧预计销售总收入 = 首轮电视播映权转让收入= 已签订销售合同金额 + 待签订合同金额 $$</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 投资 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>技术团队管理-绩效</title>
      <link href="/37156.html"/>
      <url>/37156.html</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要实行绩效管理"><a href="#为什么要实行绩效管理" class="headerlink" title="为什么要实行绩效管理"></a>为什么要实行绩效管理</h1><p>不知道你有没有遇到过这样的问题</p><blockquote><p>在团队初期的时候，大家都是劲往一块使，大家都是在一起纯粹的干活，事情干得很快，基本上上午出了个小需求，下午就给撸完上线了。<br>随着人员规模的扩大，自己的队伍扩大了5倍，甚至于10倍，一个需求被拆分到各个团队之中，拆分到不同的产品手中，协同起来往往东拉西扯，指东说西，相互推诿，协同起来贼费劲。</p></blockquote><p>如果你的团队有上述的问题，那就说明绩效管理对你来说是必要的。</p><h1 id="如何进行绩效管理"><a href="#如何进行绩效管理" class="headerlink" title="如何进行绩效管理"></a>如何进行绩效管理</h1><p>下图为阿里巴巴的价值观绩效图<br><img src="https://blog-1254114069.cos.ap-beijing.myqcloud.com/blog/2020/01/24/15798731398454.jpg" alt=""></p><h2 id="如何管理下属"><a href="#如何管理下属" class="headerlink" title="如何管理下属"></a>如何管理下属</h2><blockquote><p>令之以文<br>动之以武</p></blockquote><h2 id="如何给团队成员制定绩效"><a href="#如何给团队成员制定绩效" class="headerlink" title="如何给团队成员制定绩效"></a>如何给团队成员制定绩效</h2><h3 id="评分项"><a href="#评分项" class="headerlink" title="评分项"></a>评分项</h3><h3 id="评分方式"><a href="#评分方式" class="headerlink" title="评分方式"></a>评分方式</h3><ul><li>leader评</li><li>自评</li><li>互评</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术团队管理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>技术团队管理-晨会</title>
      <link href="/59106.html"/>
      <url>/59106.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://blog-1254114069.cos.ap-beijing.myqcloud.com/blog/2020/01/24/15798528188353.jpg" alt=""></p><h1 id="站立会议"><a href="#站立会议" class="headerlink" title="站立会议"></a>站立会议</h1><h2 id="如何开晨会"><a href="#如何开晨会" class="headerlink" title="如何开晨会"></a>如何开晨会</h2><p>每天定时、定地开站立会议，不需要事先通知，每天10点半。<br>在站立会议上每个人当且仅当回答以下3个问题：</p><blockquote><p>昨天完成了什么？<br>有什么难题需要别人帮助解决？<br>今天做什么？</p></blockquote><p>在汇报每个人的进展时，不需要汇报是如何做的，只汇报进展。<br>需要别人帮助的问题在会后单独讨论。<br>不是向team leader汇报工作，是向所有人说明清楚你正在做的事情，将要做的事情，进展以及困难。</p><h2 id="开晨会的目的"><a href="#开晨会的目的" class="headerlink" title="开晨会的目的"></a>开晨会的目的</h2><ul><li>我们团队的昨天的目标是否达成了？每个人的贡献是什么？有哪些差距？</li><li>我们团队的Sprint目标现在还有多大差距？是否延迟了？遇到了哪些问题和障碍？</li><li>为了达成Sprint的目标，我们今天的目标是什么？为了实现今天的目标，我们每个人做什么？</li></ul><blockquote><p>对齐目标<br>相互协作</p></blockquote><h2 id="如何避免僵尸站会"><a href="#如何避免僵尸站会" class="headerlink" title="如何避免僵尸站会"></a>如何避免僵尸站会</h2><h3 id="差的站会"><a href="#差的站会" class="headerlink" title="差的站会"></a>差的站会</h3><ul><li>每日站会的时间定在下班前</li><li>开会时间过长或者过短</li><li>每日站立汇报会</li><li>开站会发言表达混乱，没有主次</li><li>抛出障碍无人响应</li></ul><h3 id="好的站会"><a href="#好的站会" class="headerlink" title="好的站会"></a>好的站会</h3><ul><li>立规矩，尊重团队约定</li><li>注重团队仪式感</li><li>迭代目标明确，和每日任务紧密相关</li><li>“障碍”有出口</li><li>立规矩有原则，欢迎“刺头”</li><li><strong>打造价值共同体</strong></li></ul><p>对于团队来说规矩是最重要的，约定是最舒服的。在开发中有句这样的话“约定大于配置”。在团队管理中同样适用，约定代表着大部分的人都默认了这条规则。</p><p>仪式感，这个待定，我没有发言权，但是如果团队需要他，可以先摸索着，练练你对于团队的手感。</p><p>每天的站会一定要和目标关联起来，管理是为了做事情，不是为了“搞人”，只要心正才能带好团队，“事”是本，“管”是末，“物有本末，事有终始。知所先后，则近道矣”。</p><p>障碍有“出口”，这个事情也特别重要，如果大家提出来的问题，没有被重视或者没有被解决，大家也许就不会提问题了。久而久之又回归了僵尸之路。</p><p>欢迎“刺头”，其实这里的刺头不一定是个贬义，对于刺头不是要打死，而是要把他带领到团队的约束中来，每个人都有每个人的想法，不可能团队里面都是一个模子刻出来的。“收拾”刺头的过程就是你管理能力提升的过程，对于刺头我是这样处理的：</p><ol><li>先私下沟通，就事论事，不是强压</li><li>开大会定规矩</li><li>规矩定了，按照规矩来办事，如果还有人破规矩，则按照处罚规则来，罚完以后，不要把情绪带入其他事情中来，事后不追责，就事论事。</li><li>事不过三，申之以文，令之以武。对于屡教不改，无法融入团队的人，你应该自己心里有一杆秤，如果心理的天平倾斜到“他的存在严重影响了团队的进步和发展”的时候，就应该及时把他清理出去，不可心慈手软。妇人之仁害的是你的团队，拖沓团队要做的事情，切不可让劣币驱逐良币。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.scrumcn.com/agile/scrum/20932.html" target="_blank" rel="noopener">如何开高质量的SCRUM站立会 - Scrum中文网</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzU1MTkyNDU4MA==&amp;mid=2247484055&amp;idx=1&amp;sn=cb67435affd1bd245cf4ed961ab21d5a&amp;chksm=fb88a49cccff2d8ae722c4b94854e65fc1c53a3d7fd8363af1242235ec6afc4430a9544eb83b&amp;scene=27#wechat_redirect" target="_blank" rel="noopener">僵尸Scrum？都是因为缺少TDD</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术团队管理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>技术团队管理-项目管理</title>
      <link href="/56109.html"/>
      <url>/56109.html</url>
      
        <content type="html"><![CDATA[<h1 id="基于JIRA来做项目管理"><a href="#基于JIRA来做项目管理" class="headerlink" title="基于JIRA来做项目管理"></a>基于JIRA来做项目管理</h1><p>产品需求、技术优化、故障修复，都要建JIRA，描述清楚要做的事情，没有JIRA不开发，JIRA链接要发项目群里，故障修复、技术优化可能没项目群，就发到团队群里。<br>项目群，涉及的人员有相关PM、RD、QA。</p><h2 id="关于JIRA"><a href="#关于JIRA" class="headerlink" title="关于JIRA"></a>关于JIRA</h2><p><a href="https://www.atlassian.com/software/jira" target="_blank" rel="noopener">Jira | Issue &amp; Project Tracking Software | Atlassian</a><br>JIRA是一个敏捷开发项目管理工具，每个公司都需要有这样一个工具，国内有很多的替代方案，比如说：Teambition。</p><h2 id="关于需求评审"><a href="#关于需求评审" class="headerlink" title="关于需求评审"></a>关于需求评审</h2><p>需求评审前一天PM给出需求文档链接地址，到时技术先花个20分钟提前了解一下文档，把自己的疑惑记录下来在需求评审会上与产品沟通。<br>需求评审参与方：相关的pm、rd、qa再加上技术经理。<br>需求评审当天或者第二天，rd给出大致的工期，QA给出测试时间，估算工期的时候rd同学最好能细化一下，具体每个功能实现需要的时间。</p><h2 id="关于项目技术负责人"><a href="#关于项目技术负责人" class="headerlink" title="关于项目技术负责人"></a>关于项目技术负责人</h2><p>需求评审后，确定一位rd全程负责，作为技术方的项目owner，直至需求结束。职责包含不仅限于组织技术评审、项目推进、关键步骤反馈。</p><h2 id="关于技术评审"><a href="#关于技术评审" class="headerlink" title="关于技术评审"></a>关于技术评审</h2><p>技术评审的本质是为了明确方案、控制风险、相互交流、共同成长。<br>我们团队有个约定：一个标准项目工期超过10pd的需要做技术评审。</p><p>参与人员：rd、pm、qa、相关依赖方加上技术经理。</p><p>遇到风险大的、影响大的要主动发起技术评审。</p><p>技术评审要有存储结构的设计，流程设计，接口文档，明确关键时间点（联调时间，提测时间），咱们的文档是用的swagger生成，基本上定义好存储结构，然后在返回的bean上加一些注解文档就有了。<br>流程设计的话业务流程不复杂的话，可以弱化一些。</p><h1 id="关于测试"><a href="#关于测试" class="headerlink" title="关于测试"></a>关于测试</h1><h2 id="关于数据同步"><a href="#关于数据同步" class="headerlink" title="关于数据同步"></a>关于数据同步</h2><p>一旦涉及线上数据同步到线上，一定要提前在群里面说出来，确认不会影响其他人的流程方可同步。</p><h2 id="关于提测"><a href="#关于提测" class="headerlink" title="关于提测"></a>关于提测</h2><p>提测邮件要抄送技术经理 、技术组、QA组、产品组</p><p>包含的内容：<br>JIRA链接<br>项目访问地址<br>gitlab地址<br>一些重要的测试点</p><h2 id="关于BUG"><a href="#关于BUG" class="headerlink" title="关于BUG"></a>关于BUG</h2><p>所有的问题都要走JIRA，企业微信截图对话的方式容易忘记。<br>QA在提bug的时候，要能简单地描述清楚问题，格式不限。</p><p>建议的格式：文字+图片+相应的链接+操作人账号</p><p>当然，上面不是呆板的格式，不强制要求所有的都这样，一言以蔽之，要能够清晰准确地描述问题。好让rd能快速定位问题，通过约定来减少沟通成本。</p><p>rd在收到JIRA-bug后开始解决，如果有疑问，在群里沟通</p><p>解决完以后，点击解决问题，指回给相应的QA，让QA进行验证，验证通过，QA关闭该JIRA</p><h1 id="关于上线"><a href="#关于上线" class="headerlink" title="关于上线"></a>关于上线</h1><h2 id="预发布环境"><a href="#预发布环境" class="headerlink" title="预发布环境"></a>预发布环境</h2><p>如果有预发布环境，先上线预发布环境，上线之前现在预发布环境验收一下。</p><h2 id="上线计划"><a href="#上线计划" class="headerlink" title="上线计划"></a>上线计划</h2><p>由项目技术负责人-来负责写上线计划。<br>上线计划要点：<br>1.如果数据库表结构有修改，确认db-migration 有没有执行<br>2.新项目要和op确认域名与Nginx路由规则有没有配置好，否则上线以后会访问不通<br>3.上线顺序，前端先上还是后端先上，后端相互依赖方，谁先上谁后上，每个参与方上线以后都在群里面通知一下<br>4.回滚顺序，与上线顺序类似<br>5.对于重大复杂的项目（总工时超过10pd的项目），要做上线评审，要讨论可能存在的风险点，会不会对已有的逻辑有影响，遇到问题怎么解决，是回滚还是及时解决，对于问题过程中产生的脏数据怎么处理以及如何分辨哪些是脏数据。</p><h1 id="关于需求变更"><a href="#关于需求变更" class="headerlink" title="关于需求变更"></a>关于需求变更</h1><p>这个估计是所有互联网公司中都会出现的问题，对于项目组来说不允许需求变更，显然是不合理的，互联网公司最大的优势就是要拥抱变化，但是对于RD和QA来说显然不是希望需求发生变更的，因为可能开发到一半发现变更的需求导致了之前所有的努力都白费了。</p><p>我在团队管理的时候，一直在努力寻找这两者之间的平衡，在我们团队的协商与磨合之下得出的结论是：需求变更是可以的，我们要拥抱变化，但是要不要加工期由RD和QA来评判，加多久时间由PM、RD、QA一起商量给结果。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术团队管理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《事实》读书笔记</title>
      <link href="/46991.html"/>
      <url>/46991.html</url>
      
        <content type="html"><![CDATA[<h2 id="简评"><a href="#简评" class="headerlink" title="简评"></a>简评</h2><p>这是2019年读到的好书，本书的作者是[瑞典] 汉斯·罗斯林，他是一个医护人员同时也是一个研究员，丰富的一线医护经历让他在思考人的行为的时候有不同的角度。生活中奇奇怪怪的问题或者说偏见，作者在这本书中给了自己的见解。可惜的是，他因患胰腺癌已经离开了人世间，如果他没有这么快离去，我相信会给世界留下更多脍炙人口的作品。</p><p>很多时候我们看到的东西都是别人创造出来的意识形态，如何去识别有用的信息，这本书给出了其中一种解决方案——以数据为导向，分析数据，实事求是。</p><blockquote><blockquote><p>避免一分为二<br>避免以偏概全<br>避免单一视角<br>避免情急生乱</p></blockquote></blockquote><h2 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h2><blockquote><p>当出现以下三种情况时，你要提高警觉，有人可能会告诉你(或者你自己认为)存在一个巨大的差距，并触发你一分为二的本能。这三种情况分别是：只比较平均数、只比较极端情况和只俯视不仰视。</p></blockquote><p>这是人的天性</p><blockquote><p>你怎样才能捕捉到自己所有的错误观念呢？数据。你必须依赖数据，并且描述出数据背后所体现出来的现实世界。</p></blockquote><blockquote><p>我们要注意只比较平均数的做法。平均数之外，我们还要注意数据的实际分布。如果两组数据的分布出现了重叠，那么有可能两组之间的鸿沟并不存在。<br>我们要注意只比较极端情况的做法。在所有的群体、国家或者国民中，总会有极端情况的存在，总会有顶层和底层。而顶层和底层之间的差别，有时候是极端不公平的。即便如此，大多数仍然分布在中间状态，而在中间并不存在鸿沟。<br>我们要注意只俯视不仰视的做法。记住俯视会带来错觉，一切看起来都一样矮，但是事实并非如此。</p></blockquote><blockquote><p>我们对坏事总会比好事更加关注。这种负面思维的本能就是我们重大误解背后的第二个原因。</p></blockquote><blockquote><p>我们总是更容易注意到坏的事情，而不是好的事情。这种负面思维的本能体现在三个方面：第一，我们对过去错误的记忆；第二，媒体和社会活动家对于负面新闻的选择性报道；第三，我们总是觉得，只要有坏的事情发生，就不应该认为世界是在变好。</p></blockquote><blockquote><p>想控制我们的负面情绪，我们就要做到对坏消息要有思想准备。<br>·更好和不好。我们要学会区分状态和趋势，要认识到事情可以同时是不好的，但也是在变得更好的。<br>·好消息不是新闻。好消息是很少得到报道的，因此我们总是听到坏消息。所以当你听到坏消息的时候，可以问一下自己是否我们没有听到好的消息。<br>·循序渐进的进步不是新闻。当一件事情在持续变好，但当中产生了一些小的低谷的时候，通常你只会注意到低谷，而不是整体的趋势。<br>·更多的坏消息并不意味着更多的坏事情。我们能够听到更多的坏消息，有时仅仅是因为我们对坏事情的关注度和监控能力提高了，并不意味着这个世界在变得更坏。<br>·警惕过分美化的历史。人们经常会刻意地美化自己的历史，而国家也经常会刻意地美化自己的历史。</p></blockquote><blockquote><p>这一章，我们要讨论的是第三项错误本能：直线思维的本能。人们认为，这个世界上的人口是会一直保持增长的，这是第三个，也是最后一个人类的重大误解。请注意这个词：“一直保持”。这个词就是误解的根源。</p></blockquote><blockquote><p>控制直线思维本能的最佳方式，就是每当我们看到一条直线的时候，我们就应当想到事物的演变有多种方式，不一定是按照直线发展的。</p></blockquote><blockquote><p>拯救贫困儿童会使得世界人口一直持续增长”这种说法看似正确，实则是错误的。恰恰是生活在极度贫困状态中的人们才使得世界人口持续增长。他们中的每一代人都持续生育更多的孩子。控制人口增长的最有效手段，就是把人们从极度贫困状态中拯救出来，使他们得到更好的生活，包括基本的教育和避孕手段。一旦脱离了极度贫困状态，世界上的父母毫无例外都选择了生育更少的孩子</p></blockquote><blockquote><p>要想控制直线思维的本能，我们就需要记住，自然界有很多不同的曲线形状。<br>·不要做直线假设。有很多事物的发展并不遵循直线规律，而是遵循S形曲线、滑梯曲线、驼峰曲线或者倍增曲线的规律。没有一个孩子是按照直线的规律长高的，而且也没有父母会认为孩子的身高会无限增长。</p></blockquote><blockquote><p>现实世界变得前所未有的和平和安全的时候，我们看到的却是铺天盖地的关于各种危险的报道。<br>恐惧本能，曾经帮助我们的祖先幸存下来，而今天则帮助那些记者保住饭碗。这并不是记者的错，我们也无法寄希望于他们能够主动改变。是我们这些消费者头脑中的信息过滤机制导致了他们的行为。</p></blockquote><blockquote><p>要做到实事求是，就是当我们感到恐惧的时候，我们能够认识到我们害怕的事情不一定是真正危险的。我们对于暴力、受困以及污染的天然恐惧，会使我们习惯性地过度高估这些风险。<br>要想控制我们的恐惧本能，我们需要计算真实的风险。<br>·可怕的世界：恐惧vs.现实。我们感受到的世界，比真实的世界更可怕，这是因为我们注意到的信息都是被媒体精心选择过滤过的，而媒体刻意选择那些吓人的信息来吸引我们的注意力。<br>·风险=危险程度×发生的可能性。你面临的真实风险，并不取决于它看起来多么吓人，而在于两个因素：危险的程度和发生的概率。<br>·在采取行动之前，先让自己冷静下来。当你在恐惧中的时候，你会看到一个完全不同的世界。所以不要在恐惧中做决定。</p></blockquote><blockquote><p>人们总是容易注意局部而忽略整体。这是我们的本能之一。我们总是会注意到一个单一的数字而误判它的重要性</p></blockquote><blockquote><p>要想控制规模错觉，我们就要关注比例。<br>·对比。大的数字总是看起来很大，而单一数字很容易误导我们。当我们看到一个单一数字的时候，一定要记得做对比，或者做除法，得到某种比例。<br>·二八原则。如果你得到了一个长长的清单，就应该先排序，然后找到最大的几项并且做深入分析。通常这几项的重要性要远大于其他所有项目加在一起的重要性。<br>·比例。数字和比例有可能代表着完全不同的含义。尤其当我们在不同大小的组别之间做对比的时候，比例总是更有意义。具体来讲，我们在对国家和地区进行比较的时候，应该更加关注人均数字。</p></blockquote><blockquote><p>要想控制住我们的以偏概全的本能，我们要经常质疑自己的分类方法。<br>·在同一类别中寻找不同。特别是当一个类别非常巨大的时候，我们应该试图找到有效的办法来将其分得更小、更准确。<br>·在不同类别中寻找相同。如果你发现不同的类别之间存在着巨大的相似性，那么要考虑，你的分类方法有可能是不正确的。<br>·在不同类别中寻找不同。不要假设在一个类别中适用的规则可以在其他类别中同样适用。比如收入水平第四级的人不要假设其他级别的人也适用同样的生活规则。再比如失去意识的士兵和沉睡中的婴儿是不同的。<br>·注意大多数。大多数仅仅意味着超过一半，我们应当具体区分，大多数究竟意味着51%还是99%。<br>·注意极端案例。活灵活现的图片往往会给我们留下深刻的印象，但是它们有可能只代表着极端案例，而不是普遍现象。<br>·不要假设别人是傻瓜。当你发现一些奇怪现象的时候，请保持好奇心和谦卑之心，去探究这现象背后的道理。</p></blockquote><blockquote><p>要想控制命中注定的本能，就要记住缓慢的改变也仍然是改变。<br>·注意追踪持续的提高。每年小的改变可以在几十年后积累成巨大的改变。<br>·更新你的知识。有些知识很快就会变得过时，技术、国家、社会文化和宗教都在持续的改变当中。<br>·与老年人对话。如果你想弄清楚价值观是如何改变的，请想一想你的祖父母们的价值观和你的价值观有什么不同。<br>·收集文化改变的案例。找到反面的案例来挑战那种认为文化一成不变的说法。</p></blockquote><blockquote><p>如果你仅仅依赖媒体来形成你的世界观的话，这就好比你仅仅看着我的脚的照片来形成对我的看法。虽然我的脚是我的一部分，却是我整体上比较丑的一部分</p></blockquote><blockquote><p>人们总是倾向于认为所有的问题都有单一的原因和单一的解决方案，我把这称为人类的单一视角本能。</p></blockquote><blockquote><p>几乎我遇到的所有社会活动家，都会有意或无意地夸大他们所致力于解决的问题。</p></blockquote><blockquote><p>也许听过这样一句谚语：你给你的孩子一把锤子，他就会把所有的东西都看作钉子。<br>当你拥有某种专长的时候，你总是希望能够有机会使用它，有些时候一个专家总是试图使用他们所擅长的知识，然而他们所擅长的知识和技能却不是放之四海而皆准的。你会看到擅长数学的人永远都会对数字很执着，气候变化主义者则到处宣扬太阳能的重要性。而医生们则总会宣扬医药治疗的重要性，虽然他们明知道预防往往是更重要的。<br>知识有时候会成为专家的障碍，使他们看不到真正的解决方案。所有的解决方案，对于解决特定的问题都是很管用的，但是没有任何一种方案可以解决所有的问题。最好的方法就是以多视角来观察这个世界。</p></blockquote><blockquote><p>你的数据都是正确的，但卫生部部长的结论却是错误的。我们不是穷国中健康水平最高的国家，而是同等健康水平的国家中最穷的。”</p></blockquote><blockquote><p>要想控制单一视角的本能，必须有一个工具箱，而不仅仅是一把锤子。<br>·检查你的想法。不要仅仅专注于那些能够证明你的想法的正确案例，而要多与那些持有不同意见的人讨论。发现自己想法的不足之处。<br>·有限的经验。不要认为你在自己的专业领域之外有什么真知灼见。对自己未知的领域要保持谦逊。同时也要注意到专家也有他们的局限性。<br>·锤子和钉子。当你会熟练地使用某一种工具的时候，你总会尽可能多地使用它。等你花了太多的时间专注于分析某一个问题的时候，有可能会夸大这个问题以及解决方案的重要性。请牢记，没有任何一个工具是万能的。如果你总是习惯于使用锤子的话，那么请多和那些习惯使用改锥、扳手和卷尺的人打交道。多听听来自不同领域的人的意见。<br>·关注数字，但不仅仅关注数字。没有数字，我们无法理解世界，但是仅有数字，我们仍然无法理解世界。请专注于发现数字背后的真实世界。<br>·当心简单的想法和简单的解决方案。人类历史上从来就不缺乏充满了乌托邦式的简单想法的空想家，而最终他们都带来了可怕的结果。我们应当认识到事物的复杂性，学会兼收并蓄以及妥协。我们应当在具体情况具体分析的基础上来解决问题。</p></blockquote><blockquote><p>对世界上的绝大多数问题而言，我们不能停止于找到替罪羊，而应该观察理解产生问题的整个系统。</p></blockquote><blockquote><p>事实上，我们不应当为任何事责怪任何一个个人或团体。原因是当我们找到了替罪羊的时候，我们就停止思考了。而事实往往非常复杂，往往存在系统性的原因。如果你真的希望改变这个世界的话，你必须深刻地理解它的运行规律，而不是简单地考虑究竟该责怪谁。</p></blockquote><blockquote><p>要想控制归咎他人的本能，你应该停止寻找替罪羊。<br>·寻找原因，而不是寻找坏人。当坏事情发生的时候不要试图去责怪任何个人或群体。首先接受没有人刻意为之这个事实。然后努力去理解这一事情发生背后的系统性原因。<br>·寻找系统，而不是寻找英雄。当有人号称自己做了什么伟大的业绩的时候，问问自己，如果没有这个人，是否这件事情仍然可以发生？通常是整个系统的有效运行使得好的事情发生了。</p></blockquote><blockquote><p>请放轻松，这永远都不是真的，事情永远都没有那么紧急，而且事情永远不是非黑即白的选择。你完全可以把这本书放下，去做其他的事，过一个星期或一个月，甚至一年，你再回来，拿起这本书，重新看一看里面的主要观点，那也不会太晚。与其囫囵吞枣似的学习，还不如细嚼慢咽。</p></blockquote><blockquote><p>要做到实事求是，就要认识到当你感觉必须做一个紧急的决定的时候，牢牢地记住，事实上绝大多数情况并不是真的紧急。<br>要想控制情急生乱的本能，你需要做到循序渐进。<br>·深呼吸。当你情急生乱的本能被唤醒的时候，你的其他本能也会被激活，而你大脑的分析能力则停止工作了。请给你自己一点时间和更多的信息。绝大多数情况下，你并不需要立即采取行动，以后仍然会有机会。事实也通常不是非黑即白的。<br>·坚持了解基础数据。如果一件事是紧急且很重要的，那么我们必须对它进行持续观测。请警惕那些虽然相关但并不准确的数据，或者那些虽然准确但实际并不相关的数据。只有相关且准确的数据才真正有用。<br>·警惕那些带有偏见的预言家。任何关于未来的预测都是具有不确定性的。所有的预测都必须考虑到未来的不确定性。你应当坚持对预测有一个全面的、包含多种情形分析的了解。永远不要只看最佳或最差情形。并且要用这种预测和历史上发生的事实相对比，来检查这种预测方法的准确度。<br>·小心过激的行动。尽可能了解激烈行动的后果和副作用。了解这一行动的理论依据。应当稳扎稳打地取得现实的进步，并且在过程中持续观测实施效果。通常循序渐进的方案，总会优于大刀阔斧的行动。</p></blockquote><blockquote><p>教育下一代解决不了成年人的无知问题。你在学校里面学到的关于这个世界的知识，在十到二十年之后就会变得过时</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>learning-spider</title>
      <link href="/63944.html"/>
      <url>/63944.html</url>
      
        <content type="html"><![CDATA[<h1 id="需要学习的库"><a href="#需要学习的库" class="headerlink" title="需要学习的库"></a>需要学习的库</h1><p><a href="https://cn.python-requests.org/zh_CN/latest/" target="_blank" rel="noopener">Requests: 让 HTTP 服务人类 — Requests 2.18.1 文档</a></p><p><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/" target="_blank" rel="noopener">Beautiful Soup Documentation — Beautiful Soup 4.4.0 documentation</a></p><p><a href="https://selenium-python-zh.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">Selenium with Python中文翻译文档 — Selenium-Python中文文档 2 documentation</a></p><h2 id="练练手"><a href="#练练手" class="headerlink" title="练练手"></a>练练手</h2><p><a href="https://zhuanlan.zhihu.com/p/21320392?refer=passer" target="_blank" rel="noopener">免费实用的API接口 - 知乎</a> </p><h1 id="爬虫概述"><a href="#爬虫概述" class="headerlink" title="爬虫概述"></a>爬虫概述</h1><p>爬虫就是获取网页并提取和保存信息的自动化程序。</p><blockquote><p>获取网页<br>提取信息<br>保存数据<br>自动化程序</p></blockquote><h1 id="Requests-学习"><a href="#Requests-学习" class="headerlink" title="Requests 学习"></a>Requests 学习</h1><h2 id="开发哲学"><a href="#开发哲学" class="headerlink" title="开发哲学"></a>开发哲学</h2><blockquote><p>Beautiful is better than ugly.(美丽优于丑陋)<br>Explicit is better than implicit.(直白优于含蓄)<br>Simple is better than complex.(简单优于复杂)<br>Complex is better than complicated.(复杂优于繁琐)<br>Readability counts.(可读性很重要)</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre class=" language-bash"><code class="language-bash">pip <span class="token function">install</span> requests</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> requestsr <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'https://api.github.com/events'</span><span class="token punctuation">)</span>r <span class="token operator">=</span> requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span><span class="token string">'http://httpbin.org/post'</span><span class="token punctuation">,</span> data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'key'</span><span class="token punctuation">:</span><span class="token string">'value'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>r <span class="token operator">=</span> requests<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token string">'http://httpbin.org/put'</span><span class="token punctuation">,</span> data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'key'</span><span class="token punctuation">:</span><span class="token string">'value'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>r <span class="token operator">=</span> requests<span class="token punctuation">.</span>delete<span class="token punctuation">(</span><span class="token string">'http://httpbin.org/delete'</span><span class="token punctuation">)</span>r <span class="token operator">=</span> requests<span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token string">'http://httpbin.org/get'</span><span class="token punctuation">)</span>r <span class="token operator">=</span> requests<span class="token punctuation">.</span>options<span class="token punctuation">(</span><span class="token string">'http://httpbin.org/get'</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'key1'</span><span class="token punctuation">:</span> <span class="token string">'value1'</span><span class="token punctuation">,</span> <span class="token string">'key2'</span><span class="token punctuation">:</span> <span class="token string">'value2'</span><span class="token punctuation">}</span>r <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"http://httpbin.org/get"</span><span class="token punctuation">,</span> params<span class="token operator">=</span>payload<span class="token punctuation">)</span></code></pre><p>其中 data 属性用于传递body属性，params用于传递url 参数.</p><p>如果想要传递cookies到服务器，可以使用cookies参数</p><p>如果想要传递headers到服务器，可以使用headers参数<br>下图是完整的列表<br><img src="https://blog-1254114069.cos.ap-beijing.myqcloud.com/blog/2020/01/17/15792515222074.jpg" alt=""></p><h3 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h3><p><code>r</code>保存的是一个response对象，对象中的属性如下：</p><table><thead><tr><th>属性名或者方法</th><th>属性含义</th></tr></thead><tbody><tr><td>status_code</td><td>响应状态码</td></tr><tr><td>headers</td><td>响应头</td></tr><tr><td>json()</td><td>返回内容为JSON</td></tr><tr><td>content</td><td>二进制响应内容</td></tr><tr><td>raw</td><td>原始响应内容</td></tr></tbody></table><h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><h3 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h3><p>基本身份认证<br>OAuth 认证<br>OAuth2 认证</p><h1 id="Selenium-学习"><a href="#Selenium-学习" class="headerlink" title="Selenium 学习"></a>Selenium 学习</h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><pre class=" language-bash"><code class="language-bash">pip <span class="token function">install</span> selenium</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>王阳明-心学</title>
      <link href="/13066.html"/>
      <url>/13066.html</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要学王阳明"><a href="#为什么要学王阳明" class="headerlink" title="为什么要学王阳明"></a>为什么要学王阳明</h1><blockquote><p>内心要足够强大<br>所做的事情要能在自己的操作系统中逻辑自洽</p></blockquote><h2 id="心即理"><a href="#心即理" class="headerlink" title="心即理"></a>心即理</h2><p>龙场悟道</p><h2 id="致良知"><a href="#致良知" class="headerlink" title="致良知"></a>致良知</h2><p>江西平叛</p><blockquote><p>破山中贼易，破心中贼难</p></blockquote><h2 id="知行合一"><a href="#知行合一" class="headerlink" title="知行合一"></a>知行合一</h2><blockquote><blockquote><p>知与行本身就是一体<br>一念发动处即是行</p></blockquote></blockquote><h2 id="四句教"><a href="#四句教" class="headerlink" title="四句教"></a>四句教</h2><p>南征广西</p><blockquote><p>无善无恶心之体<br>有善有恶意之动<br>知善知恶是良知<br>为善去恶是格物</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 哲学 </category>
          
          <category> 心学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 王阳明 </tag>
            
            <tag> TODO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用hexo+mweb进行高效写作</title>
      <link href="/9554.html"/>
      <url>/9554.html</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>上一篇文章中已经介绍如何基于hexo + github-pages搭建自己的博客站点，搭建和部署是及其简单的，困难的是把写作这件事情坚持下来。</p><a id="more"></a><p>MarkDown文档格式对程序员比较友好，对于普通的文字工作者来说就不是那么友好了，所以需要一把利器来帮忙解决markdown编写的问题。</p><h3 id="mweb设置"><a href="#mweb设置" class="headerlink" title="mweb设置"></a>mweb设置</h3><p><a href="https://zh.mweb.im/" target="_blank" rel="noopener">MWeb - 专业的Markdown写作、记笔记、静态博客生成软件 - MWeb</a><br>里面有详细的购买方法（原创不易，支持一下）</p><p>唯一需要配置的就是设置图床<br>添加图床配置，我用的是七牛云<br><img src="http://ody8qw44c.bkt.clouddn.com/2018-09-26-15379637472167.jpg" alt=""><br><img src="https://blog-1254114069.cos.ap-beijing.myqcloud.com/blog/2020/01/14/15789889148863.jpg" alt=""></p><p><img src="http://ody8qw44c.bkt.clouddn.com/15379635104626.jpg" alt=""></p><h3 id="next-主题配置"><a href="#next-主题配置" class="headerlink" title="next 主题配置"></a>next 主题配置</h3><p><a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener">hexo的next主题个性化教程:打造炫酷网站 | Moorez</a></p><p><a href="https://shjhe.github.io/hexo/2018/07/04/Hexo%20Next%E4%B8%BB%E9%A2%98%E5%BC%80%E5%90%AF%E5%AD%97%E6%95%B0%E7%BB%9F%E8%AE%A1%E5%8F%8A%E9%98%85%E8%AF%BB%E6%97%B6%E9%95%BF/" target="_blank" rel="noopener">Hexo Next主题开启字数统计及阅读时长 | Tyler FE</a></p><p><a href="https://blog.runningcoder.me/2018/04/26/create-personal-blog-with-github-and-hexo-V/" target="_blank" rel="noopener">手摸手教你用github和hexo搭建个人博客（五） | Kevin的博客</a></p><h3 id="hexo-theme-matery"><a href="#hexo-theme-matery" class="headerlink" title="hexo-theme-matery"></a>hexo-theme-matery</h3><p><a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/" target="_blank" rel="noopener">Hexo博客主题之hexo-theme-matery的介绍 | 闪烁之狐</a></p><h3 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h3><p>引用相同站点内其他资源时采用站点内地址形式<br>post_link 标签</p><pre class=" language-Hexo"><code class="language-Hexo">{% post_link hello-world %}</code></pre><h3 id="COS-腾讯云存储-与MWeb结合"><a href="#COS-腾讯云存储-与MWeb结合" class="headerlink" title="COS(腾讯云存储)与MWeb结合"></a>COS(腾讯云存储)与MWeb结合</h3><!--[tencentyun/coscmd](https://github.com/tencentyun/coscmd)MWeb支持直接上传文件至腾讯云的服务器，用于替代七牛云正如参考文章中说的，每次在开机的时候需要手动启动一下服务，--><!--coscmd config -a AKIDGK9uQgxSxCD2cyoze3C5i6E5h5GCENaP -s jEUVUFl23oJYYIm35sRmrIUQ6WgbHhrl -b blog-1254114069 -r ap-beijing--><!--```pm2 start --name qcloud-cos-mweb ./run.sh```--><p>直接使用图床服务<br><img src="https://blog-1254114069.cos.ap-beijing.myqcloud.com/blog/2020/01/14/15789963119518.jpg" alt=""></p><h3 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h3><p><a href="https://likfe.com/2018/05/03/github-pages-custom-domains-support-https/" target="_blank" rel="noopener">GitHub Pages 对自定义域名支持 HTTPS | Cafeting</a></p><h3 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h3><p><a href="https://blog.sky03.cn/posts/42790.html#toc-heading-17" target="_blank" rel="noopener">Hexo进阶之各种优化 | Sky03’s Blog</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>企业财务报表分析-张新民</title>
      <link href="/64298.html"/>
      <url>/64298.html</url>
      
        <content type="html"><![CDATA[<h1 id="财务报表"><a href="#财务报表" class="headerlink" title="财务报表"></a>财务报表</h1><h2 id="资产负债表"><a href="#资产负债表" class="headerlink" title="资产负债表"></a>资产负债表</h2><p>资产=负债+股东权益<br>右边归结起来一句话：资源的权益归属。</p><a id="more"></a><h3 id="资产分类"><a href="#资产分类" class="headerlink" title="资产分类"></a>资产分类</h3><p>按照流动性分可以分为流动资产与非流动资产<br>流动资产：一年内（也可以说是一个经营周期，因为房地产等特殊行业一个经营周期一般为3年以上）可变现为货币的资产<br>主要包括：</p><ul><li>货币</li><li>债权</li><li>存货</li></ul><p>债权包括：所有的应收和预付都归结到债权资产类。</p><p>相应的是非流动资产（长期利用的资产），包括：</p><ul><li>长期投资类</li><li>固定资产类</li><li>无形资产类</li></ul><p>长期投资类包括：可供出售金融资产、持有至到期投资（长期债权投资）、长期股权投资（这是分析的重点）。</p><p>按照资产对利润的共享方式可以分为经营资产和投资资产。<br>经营资产包括：</p><ul><li>货币</li><li>债权</li><li>存货</li><li>固定资产</li><li>无形资产</li></ul><p>投资资产包括：</p><ul><li>可供出售金融资产</li><li>持有至到期投资</li><li>长期股权投资</li><li>交易性金融资产</li></ul><p>这种资产划分的方式更有意义，不是资产的流动和非流动解决利润的转化问题，而是经营和投资与流动和非流动的结合解决了我们的分析问题。<br>有些企业只有经营没有投资，有些企业只有投资很少有经营，有些企业是经营和投资并重。</p><h3 id="资源的权益归属"><a href="#资源的权益归属" class="headerlink" title="资源的权益归属"></a>资源的权益归属</h3><p>包括：</p><ul><li>债权人——负债</li><li>股东（所有者）——股东所有者权益</li></ul><p>资产形态的变化不影响负债和股东权益价值量的变化。比如说：借款1亿，这个时候负债就是1亿，在经营过程中花掉了5000万转化为固定资产，这个时候资产变为5000万固定资产和5000万货币。</p><p>负债按照偿还期的长短也分为流动负债和非流动负债。</p><p>股东权益构成：</p><ul><li>实收资本（股本）</li><li>资本公积</li><li>盈余公积</li><li>未分配利润</li></ul><h2 id="利润表"><a href="#利润表" class="headerlink" title="利润表"></a>利润表</h2><p>收入-费用 = 净利润<br>收入：凡是使利润增加的因素都是收入。<br>费用：凡是使利润减少的因素都是费用。</p><h2 id="现金流量表"><a href="#现金流量表" class="headerlink" title="现金流量表"></a>现金流量表</h2><p>反映企业一定时间现金及现金等价物（货币资金）收支情况的报表。<br>现金流入量-现金流出量=现金流净额<br>经营活动、投资活动和筹资活动。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>资产负债表</p><table><thead><tr><th>表</th><th align="left">说明什么问题</th><th align="left">概况</th><th align="left">另外一种角度</th></tr></thead><tbody><tr><td>资产负债表</td><td align="left">资源结构以及权益归属</td><td align="left">实力（财力）</td><td align="left">底子</td></tr><tr><td>利润表</td><td align="left">一定时期的权益</td><td align="left">能力</td><td align="left">面子</td></tr><tr><td>现金流量表</td><td align="left">强调钱怎么来，怎么花</td><td align="left">活力</td><td align="left">日子</td></tr></tbody></table><p>造假最容易的是在面子，就像是人的化妆一样，面子最容易伪造。造假最重要的一个特征就是反常识。</p><h1 id="企业设立、经营与财务报表"><a href="#企业设立、经营与财务报表" class="headerlink" title="企业设立、经营与财务报表"></a>企业设立、经营与财务报表</h1><p>资产负债表表是一个综合反映，利润表是一段时期的效益表现，现金流量表是收支变化情况。<br>一般而言，现金流量表是对资产负债表中第一行货币一段时间内的展开说明。<br>利润表和现金流量表是对资产负债表中某一项或者某几项的补充说明。</p><p>盈余公积和未分配利润是净利润的分配结果。</p><p>存货：用于销售的产品。</p><p>对外交易会产生收入，得到的是货币或者是债权。</p><p>股东入资的三重效应：</p><ul><li>为经营奠定基础</li><li>对潜在的债务提供保证</li><li>确立股东之间的利益关系</li></ul><h1 id="企业发展、扩张与财务报表"><a href="#企业发展、扩张与财务报表" class="headerlink" title="企业发展、扩张与财务报表"></a>企业发展、扩张与财务报表</h1><p>前面已经说过，资产按照对利润的共享可以分为经营资产与投资资产。</p><h2 id="企业发展与扩张的两个途径："><a href="#企业发展与扩张的两个途径：" class="headerlink" title="企业发展与扩张的两个途径："></a>企业发展与扩张的两个途径：</h2><ul><li>自主经营</li><li>对外控制性投资</li></ul><h2 id="扩张的资金来源"><a href="#扩张的资金来源" class="headerlink" title="扩张的资金来源"></a>扩张的资金来源</h2><p>有两个渠道：</p><ul><li>筹资：股东给，银行借</li><li>经营利润积累</li></ul><p>股东不可能天天给，企业开始的时候股东才会给，当然上市公司可以增发股份，股东给了钱以后可以通过经营活动赚取利润。<br>银行借款是企业经常性的扩张现金来源。</p><h3 id="扩张的资金投向"><a href="#扩张的资金投向" class="headerlink" title="扩张的资金投向"></a>扩张的资金投向</h3><ul><li>无形资产</li><li>固定资产</li><li>在建工程</li></ul><p>重大的扩张一般都不是先形成固定资产，先形成在建工程，在建工程一般时间跨度大，最终形成固定资产，也有可能是坏掉的在建工程。<br>在建工程是没有支持近期的经营活动的，没有经营行为。</p><p>一个现象：很多时候现金流量表的自由现金流(经营现金流量净额+投资现金流量净额)&lt;0，说明有资金缺口，这里面的原因往往和在建工程相关。这种情况不需要过分担心，关键在于投资效益几何。投资现金流量净额小于零说明企业在扩张。</p><p>如果在建工程时间过程会产生两个后果：</p><ul><li>单位产能成本过高（周期过长，利息因素会过高）；</li><li>行业产能过剩，建造时信心满满，建造完成时却生产过剩，这个时候是重大的投资失误。</li></ul><h2 id="控制性投资对企业的影响"><a href="#控制性投资对企业的影响" class="headerlink" title="控制性投资对企业的影响"></a>控制性投资对企业的影响</h2><h3 id="控制性投资的撬动效应"><a href="#控制性投资的撬动效应" class="headerlink" title="控制性投资的撬动效应"></a>控制性投资的撬动效应</h3><p>控制性投资是企业在不对外融资的前提下，实现跨越式发展的重要方式。</p><p><strong>货币资金存量根本就不是完全可自由动用的货币资金。</strong></p><p>前面说扩张有两种：自主经营和控制性投资<br>自主经营的好处是自己做自己赚，所有的利润都是自己的，但是同时所有的风险都是自己承担。<br>有时为了规避风险，通过对外控制性投资，成立控股子公司，引入第三方资金一起做新的产品线，达到扩张的目的。<br>对外控制性投资投入的资金在母公司资产负债报表上表现为<code>长期股权投资</code>。<br>由于是子公司是控股公司，所以会归入合并报表。<br>子公司的资产负债表、利润表、现金流量表会归入企业合并报表。</p><h3 id="控制性投资的识别问题"><a href="#控制性投资的识别问题" class="headerlink" title="控制性投资的识别问题"></a>控制性投资的识别问题</h3><p>可能包含控制性股权投资的项目：</p><ul><li>长期股权投资</li></ul><p>长期股权投资并不都是控制性投资并不都是控制性投资，如何识别控制性股权投资的规模？<br>控制性股权投资的规模 = 母公司的长期股权投资 - 合并资产的长期股权投资 + 母公司其他应收款 - 合并报表其他应收款<br>前者是入资，后者是筹资。</p><p>长期股权投资<br>通过控制性股权投资注资以后，子公司需要额外的资金怎么办，这个时候子公司需要借钱，一般而言对于集团而言都不是分散筹资的，而是集团统一借钱，然后再给子公司按需分配下去，这样会整个集中一个集团融资的一种能力和潜力，能够获得一个比较好的贷款条件。<br>贷款1亿和贷款100亿对于银行来说是不一样的，银行更愿意给大集团贷款以规避风险。</p><p>拿到控制性投资的总额以后，可以算出一个控制性投资总额占资产总额的一个比例，看出公司是否是对外投资为主导。</p><h3 id="撬动效应"><a href="#撬动效应" class="headerlink" title="撬动效应"></a>撬动效应</h3><p>$$  撬动效应 = \dfrac{合并报表资产总额 - 母公司资产总额}{控制性股权投资总额} $$</p><p>子公司也是公司，母公司可以做的时候，子公司全部可以做，比如说：筹资，经营利润</p><p>撬动效应可以看到子公司的经营情况。</p><h3 id="控制性投资效益表现形式"><a href="#控制性投资效益表现形式" class="headerlink" title="控制性投资效益表现形式"></a>控制性投资效益表现形式</h3><p>控制性投资是被控制公司的经营资产。<br>子公司的基本效益表现在子公司的核心利润里面。</p><p>子公司分红表现为母公司的投资收益。</p><h1 id="从财务报表看战略"><a href="#从财务报表看战略" class="headerlink" title="从财务报表看战略"></a>从财务报表看战略</h1><p>战略对于一家企业来说非常重要，没有企业没有战略，但是没有企业天天讲战略，战略是融入到企业骨髓中去的。</p><p>创业最重要的三件事情：<code>找人、找钱和定战略</code><br>战略的实施需要有资源的支持，只要是资源的动用就一定会在报表中留下痕迹。<br>当股东在设立的时候想的问题就是战略问题。<br>企业家见面不会交流战略问题，一般聊的是两个问题：资金（财务管理）问题与营销（市场）问题。</p><h2 id="战略实施的资源基础"><a href="#战略实施的资源基础" class="headerlink" title="战略实施的资源基础"></a>战略实施的资源基础</h2><p>静态问题与动态问题<br>静态：强调现有的资源结构的战略含义，资产负债表中资源的结构和规模。<br>动态：一段时期内资源流出量的一种关系。</p><p>现金流量表中的投资活动流出量中有两项：购建固定资产（经营相关），投资支付现金（投资相关）。<br>这两项可以看出企业是更强调于自主经营还是对外投资扩张。<br>企业不和外界发生资源交互是不可能的。<br>企业的成功光有自身的努力是不够的。应该站在更大的环境中看企业的发展，因为大环境可能会变，所以企业的战略也会调整，动态的调整在报表中会有痕迹。</p><h2 id="行业的选择与定位"><a href="#行业的选择与定位" class="headerlink" title="行业的选择与定位"></a>行业的选择与定位</h2><ul><li><p>行业选择决定了基本的资产结构。<br>最明显的是固定资产与存货之间的关系。</p></li><li><p>定位：资源、产品定位与市场占有率。<br>我们看一个企业不应该仅仅看资源结构与资源能力，也要看利润效益。<br>定位既包含资源规模问题，又包含产品形象问题。<br>市场占有率往往看产品销量和营业额。</p></li><li><p>扩张战略及其效应<br>对内扩大经营及效应，增加产能<br>对外控制性投资及（撬动效应以外的）效应：资产盘活效应，风险分散效应。<br>控制性股权投资有两个作用：撬动效应和分散风险。<br>案例分析：小型企业低价转让股份给上市公司。</p></li></ul><h2 id="财务分析视角看战略"><a href="#财务分析视角看战略" class="headerlink" title="财务分析视角看战略"></a>财务分析视角看战略</h2><p>全体股东的视角：</p><ul><li>企业资源的一种系统性优化</li><li>它的变化的盈利导向</li></ul><p>所谓系统性优化就不是某类或者某项资产的局部最优，而是强调特定资产在整体中对盈利的贡献。<br>如果年末余年初相比变化很明确，那一定要考虑是否对盈利有贡献。</p><p>控制性股东（或者说大股东）视角<br>如果控股股东（或者说大股东）与全体股东的立场不一致，则控股股东的战略实施就会导致本公司不良资产的形成。<br>如果企业家上市之前干什么什么就成，但是上市以后干什么什么都有问题的时候，可能就是这种情况，控股股东的利益与全体股东利益有冲突。</p><h1 id="从报表看企业竞争力"><a href="#从报表看企业竞争力" class="headerlink" title="从报表看企业竞争力"></a>从报表看企业竞争力</h1><p>竞争力是一种比较优势，一定是和同行业的相比的竞争力</p><h2 id="企业竞争力的财务报表表现"><a href="#企业竞争力的财务报表表现" class="headerlink" title="企业竞争力的财务报表表现"></a>企业竞争力的财务报表表现</h2><p>流动比率与速动比率其实没有什么用。<br>$$  流动比率 = \dfrac{流动资产}{流动负债} $$</p><p>为什么有货币资金还有短期借款，这个是短期借款的安排问题。子公司的贷款都是通过集团来向银行贷款的，以其他应收款（母公司给子公司提供资金的通道）的形式出借给子公司。其他应收款是集团资金管理的安排问题。</p><p>流动资产的核心部分：货币、预付款项、应收票据、应收账款、存货<br>流动负债的核心部分：短期借款、应付票据、应付账款、预收款项</p><h2 id="上下游关系管理"><a href="#上下游关系管理" class="headerlink" title="上下游关系管理"></a>上下游关系管理</h2><h3 id="收款（对下游）过程管理"><a href="#收款（对下游）过程管理" class="headerlink" title="收款（对下游）过程管理"></a>收款（对下游）过程管理</h3><p>$$  应收账款周转率 = \dfrac{营业收入}{平均应收账款} $$<br>==这个指标也是没有多大用处的==<br>企业的债权回收是应收票据、应收账款与预收款项共同推动了一个企业的营业收入额。上面的公式只用了应收账款一项内容，显然是不对的。</p><p>应收账款我们要看的是回款状况，周转速率不是很重要，回款状况和企业的营销策略以及市场竞争地位密切相关。<br>收款状况我们看三个指标：应收票据、应收账款与预收款项。<br>应收票据+应收账款 作为整体看年初与年末的关系<br>看规模，看年末的数据与年初的数据相比。<br>看结构，应收票据是优于应收账款的。</p><p>同理再看预收款项。<br>$$  对下游 = (年末预收 - 年初预收) -（年末应收 - 年初应收） $$<br>这个值越大则对下游的控制力越强<br>得到数据之后与今年的营业额对比来看，看今年的回款情况。</p><h3 id="付款（对上游）过程管理"><a href="#付款（对上游）过程管理" class="headerlink" title="付款（对上游）过程管理"></a>付款（对上游）过程管理</h3><p>看四个指标：应付票据、应付账款、预付款项和存货。<br>$$ 对上游 = 应付-预付-存货 $$</p><p>上下游关系管理一定会反映在经营现金流量上面。<br>应收票据与应收账款的结构是一种竞争优势的体现，吃上游（供应商）的能力是一种竞争优势，吃下游（经销商）的能力是一种竞争优势。</p><h2 id="毛利、毛利率与竞争力"><a href="#毛利、毛利率与竞争力" class="headerlink" title="毛利、毛利率与竞争力"></a>毛利、毛利率与竞争力</h2><p>基本的盈利能力看毛利与毛利率<br>$$ 毛利 = 营业收入 - 营业成本 $$<br>$$ 毛利率= \dfrac{营业收入 - 营业成本}{营业收入}$$</p><h2 id="核心利润、核心利润率与竞争力"><a href="#核心利润、核心利润率与竞争力" class="headerlink" title="核心利润、核心利润率与竞争力"></a>核心利润、核心利润率与竞争力</h2><p>$$ 核心利润 = 毛利 - 营业税金及附加 - 销售费用 - 管理费用 - 财务费用 $$<br>$$ 核心利润率 = \dfrac{毛利 - 营业税金及附加 - 销售费用 - 管理费用 - 财务费用}{营业收入}  $$</p><p>核心利润表明企业经营资产的盈利能力。</p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>企业的竞争力与风险绝不在于流动资产与流动负债的比例。<br>==强调一下：如果一家企业低流动资产对较高流动负债存在并且<code>长期存在</code>，它表明这家企业有一种竞争优势，结合上下游关系管理来分析==</p><h2 id="ROA与ROE"><a href="#ROA与ROE" class="headerlink" title="ROA与ROE"></a>ROA与ROE</h2><p>总资产收益率与净资产收益率<br>一个企业的利润是0并不代表企业没有价值。</p><p>竞争力的财务表现是持续的盈利表现。</p><h1 id="从报表看企业效益和质量"><a href="#从报表看企业效益和质量" class="headerlink" title="从报表看企业效益和质量"></a>从报表看企业效益和质量</h1><p>收入 - 费用 = 净利润<br>使利润增加的因素或者项目叫做收入<br>使利润减少的因素或者项目叫做费用<br>一般谈企业的效益的时候都是说净利润，但是仅仅看净利润是不够的，我们必须要关注利润的结构问题。</p><h2 id="几个重要的指标"><a href="#几个重要的指标" class="headerlink" title="几个重要的指标"></a>几个重要的指标</h2><h3 id="毛利"><a href="#毛利" class="headerlink" title="毛利"></a>毛利</h3><p>$$ 毛利 = 营业收入 - 营业成本 $$<br>意味着企业最基本的产品的最初盈利能力</p><h3 id="核心利润"><a href="#核心利润" class="headerlink" title="核心利润"></a>核心利润</h3><p>$$ 核心利润 = 毛利 - 营业税金及附加 - 销售费用 - 管理费用 - 财务费用 $$<br>核心利润表明经营资产的盈利能力。<br>财务费用与筹资有关，有的算法中是没有将财务费用放置到核心利润里面的，但是筹资往往与经营相关。</p><h3 id="营业利润"><a href="#营业利润" class="headerlink" title="营业利润"></a>营业利润</h3><p>$$ 营业利润 = 核心利润 + 投资收益 + 公允价值变化 - 资产减值损失<br>=  毛利 - 营业税金及附加 - 销售费用 - 管理费用 - 财务费用  + 投资收益 + 公允价值变化 - 资产减值损失 $$<br>专注于主营活动的或者核心业务的企业来讲公允价值变动收益一般不会很大，资产减值损失一般也不会很大<br>所以营业利润的两大重要支柱就是核心利润和投资收益。</p><h3 id="利润总额"><a href="#利润总额" class="headerlink" title="利润总额"></a>利润总额</h3><p>$$ 利润总额 = 营业利润 + 营业外利润 =  营业利润 + 营业外收入 - 营业外支出 $$<br>营业外收入一般为政府补贴收入</p><h3 id="净利润"><a href="#净利润" class="headerlink" title="净利润"></a>净利润</h3><p>净利润就是利润总额减去所得税费用<br>如果企业有控制性投资，企业就需要编制两张利润表，一张是本公司（母公司）利润表，一张是包括子公司的合并利润表。</p><p>合并报表中有一个归属于母公司所有者的净利润，如果公司对子公司不是完全控股的话，归属于母公司所有者的净利润就是母公司控股部分的净利润，剩余部分是少数股东损益。<br>母公司报表的净利润是母公司分红的基础，如果企业要分红，用的是母公司报表的净利润为基础进行分红。<br>合并报表的净利润是评估一个集团的盈利能力指标。<br>归属于母公司所有者的净利润只是一种观念上的表达。</p><h2 id="利润的结构与利润的质量"><a href="#利润的结构与利润的质量" class="headerlink" title="利润的结构与利润的质量"></a>利润的结构与利润的质量</h2><h3 id="营业收入的规模与结构变化"><a href="#营业收入的规模与结构变化" class="headerlink" title="营业收入的规模与结构变化"></a>营业收入的规模与结构变化</h3><p>看规模的时候要看年度间，谈企业的成长性的时候我们一般会看营业额的增长情况。<br>看结构的时候，更多的时候要强调结构变化与持续盈利能力之间的关系问题。<br>比如说有的企业的产品受国家宏观政策的影响比较大，如果没有替代能力的话，原有的结构可能不会有持续盈利的能力。<br>再者看结构的变化与企业竞争优势之间的关系？<br>生产的产品毛利率很高，并且保持一种比较强的市场份额，那么这种结构就是好的结构。市场要认可你的产品才行。</p><h3 id="毛利率的变化"><a href="#毛利率的变化" class="headerlink" title="毛利率的变化"></a>毛利率的变化</h3><p>谈毛利率强调两个问题：</p><ul><li>毛利率体现一种竞争力</li><li>但是存货积压能导致当期毛利率的提高</li></ul><p>存货积压并不完全是因为管理失当造成的积压，存货积压有两种类型：</p><ul><li>管理失当——实物积压</li><li>利润操纵——账面积压</li></ul><p>积压是指超过正常需求的储备，实物积压意味着产大于销，这时单位产品分摊的成本就比较低，积压的存货会分摊固定的成本，所以这时销售成本就会降低，这时毛利率就会提高。<br>账面积压，有些存货已经被卖掉了，但是没有从报表中剔除。<br>从根本上来看存货积压绝不是一个好现象，往往会为未来的亏损奠定基础。</p><h3 id="费用额与费用率的变化"><a href="#费用额与费用率的变化" class="headerlink" title="费用额与费用率的变化"></a>费用额与费用率的变化</h3><p>企业相当多的费用在年度间的稳定性是非常强的，其变化往往伴随着业务的变化。</p><h3 id="资产减值损失"><a href="#资产减值损失" class="headerlink" title="资产减值损失"></a>资产减值损失</h3><p>一个主业突出的企业，其资产减值损失不会太高，资产减值损失意味着相应资产的管理质量。<br>存货减值意味着存货管理有问题，债权有减值意味着债权的管理有问题，固定资产减值意味着固定资产管理有问题。</p><h3 id="投资收益"><a href="#投资收益" class="headerlink" title="投资收益"></a>投资收益</h3><p>如果有控制性投资的话，投资收益的规模取决于子公司的分红情况。</p><h3 id="营业外收入"><a href="#营业外收入" class="headerlink" title="营业外收入"></a>营业外收入</h3><p>营业外收入持续性比较强的话，则说明其中有其内在的东西。<br>一般而言与政府补贴相关。<br>如果是小打小闹的营业外收入的话，通过变卖资产，那这种对利润的贡献是不能持久的。<br>注意：如果持续性比较强的营业外收入是由于政策的问题，那么需要关注这种政策的持久性问题。</p><h2 id="核心利润的现金能力与利润质量"><a href="#核心利润的现金能力与利润质量" class="headerlink" title="核心利润的现金能力与利润质量"></a>核心利润的现金能力与利润质量</h2><p>经营活动产生的现金流量净额规模所包含的核心利润质量信息。</p><p>核心利润 * (1.2 ~ 1.5) 应该等于经营现金流量净额，前提是企业的存货周转次数应该超过2次。周转次数太慢的话，这个关系是不成立的。<br>存货周转次数 = 销货成本 / 平均存货（存货周转次数=销售成本/存货平均余额）。<br>貌似这个对于影视行业不太适用，存货周转次数太小。<br>销货成本也就是营业成本。<br>良性发展的企业肯定是有利润更有经营现金流量。</p><h1 id="从报表看风险"><a href="#从报表看风险" class="headerlink" title="从报表看风险"></a>从报表看风险</h1><h2 id="经营风险"><a href="#经营风险" class="headerlink" title="经营风险"></a>经营风险</h2><p>公司的资产有经营资产与投资资产，经营资产会产生核心利润，控制性资产投资是被控制公司的经营资产，子公司的经营产生子公司的核心利润。</p><p>与未来盈利能力不确定性相关的各种因素，各种比率：</p><ul><li>流动资产与流动负债，更多地强调短期经营与周转关系，没有一个定量的比例，流动资产与流动负债的背后一定与上下游关系管理相关</li><li>毛利率</li><li>核心利润率</li><li>存货周转率<h2 id="财务风险"><a href="#财务风险" class="headerlink" title="财务风险"></a>财务风险</h2>实际上就是贷款融资的风险<br>关心资产负债率，一般来说资产负债率超过70%，企业的财务风险就比较大了，当然特定行业有行业的特性。<br>为啥是70%，因为超过70%，董事会的决议就没有足够的权利，需要开临时股东大会，这时会影响管理层的决策影响力。</li></ul><p>偿贷能力和现金流量相关<br>核心利润率与融资之间也有关系，经营风险与财务风险是密切相关的，经营风险越低，财务风险不可能很高，一般来说是马太效应，经营越好的公司，贷款越容易，贷款的利率也会越低，掌握话语权。</p><p>贷款看三品：人品，产品，押品。<br>人品是管理层，产品看盈利能力，押品是保障措施问题<br>财务风险，不能简单看企业的资产负债率问题。<br>流动负债里面也要看结构。在预收款比较高的企业负债率是被虚夸了的，其实预收虽然在负债中，但是是一种竞争优势的体现，想象一下，货还没有给别人，钱已经收上来了，说明产品很抢手。</p><h2 id="股权结构、公司治理与核心人物变更风险"><a href="#股权结构、公司治理与核心人物变更风险" class="headerlink" title="股权结构、公司治理与核心人物变更风险"></a>股权结构、公司治理与核心人物变更风险</h2><ul><li><p>股权结构的集中、分散与风险<br>股权集中度越高，越能体现第一大股东的权利与意志。</p></li><li><p>还要注意股东大会、董事会以及管理层之间的关系与风险<br>股东是所有权，管理层是经营权。<br>核心管理层一般来讲不会超过10人。<br>董事会成员一般是5~19人之间，一般为单数，便于投票。</p><h2 id="惯性依赖风险"><a href="#惯性依赖风险" class="headerlink" title="惯性依赖风险"></a>惯性依赖风险</h2><p>技术挂帅<br>营销挂帅<br>什么样的战略就会配置什么样的资源，产品的市场定位，一般发生变更会是一个潜在的风险。风险一般会体现在上下游关系管理中，一定是供应商与经销商比利润更敏感。</p><h2 id="竞争环境变化风险"><a href="#竞争环境变化风险" class="headerlink" title="竞争环境变化风险"></a>竞争环境变化风险</h2><p>竞争地位的变化，处于不同地位的企业话语权是不一定的，有的企业总是领袖，如果竞争地位出现变化，那企业的行为跟它的竞争对手之间的关系一定会发生变化。<br>营业外收入依赖的是政策的持续性，如果政策发生变化，那么依赖这项政策的营业外收入的就不可持续了。<br>特定地区的行政领导人变更也会产生潜在的风险。</p><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>能够计算出来的风险是经营风险与财务风险<br>计算不出来的风险是公司治理，股权结构，核心人员变更，竞争环境变化的风险<br>企业的真正风险是那些不能直接计算出来的因素</p></li></ul><h1 id="从报表看前景"><a href="#从报表看前景" class="headerlink" title="从报表看前景"></a>从报表看前景</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 投资 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>韭菜的自我修养-读书笔记</title>
      <link href="/11332.html"/>
      <url>/11332.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://book.douban.com/subject/30314653/" target="_blank" rel="noopener">韭菜的自我修养 (豆瓣)</a></p><ul><li><p>韭菜是什么？<br>所谓“韭菜”，指的是在交易市场中没有赚到钱甚至赔钱的势单力薄的散户。<br>另外一个特征就是，他们严重缺乏基本的阅读能力。他们是那种买一辈子东西都不读产品说明书的人，他们是那种无论拿到什么，都要问别人怎么用的人……</p><a id="more"></a></li><li><p>韭菜之所以是韭菜，绝大多数情况下只不过是来自同一个原因：<br>他们一进场就开始“买买买”！</p></li><li><p>一旦你需要用钱的时候，市场就会大跌！<br>这个看起来没有逻辑支持，但是这个定律有着惊人的魔力。</p></li><li><p>还有钱的话，就慢慢补仓；钱不够的话，就在场外拼命赚钱。</p></li><li><p>思考带来决策，决策带来行动，行动改变命运</p></li><li><p>区分投机者和投资者的一个标准：<br>投机者拒绝学习，投资者善于学习。<br>交易之前，认真研究，深入学习；交易过后，无论输赢，都要总结归纳，修正自己的观念和思考，以便完善下一次的决策，这么做的人，在我眼里都是投资者，哪怕他们是“快进快出”。</p></li><li><p>“韭菜”们最大的共识是什么呢？<br>据我观察，所有的韭菜都认同一个实际上错误的观点：<br>所谓交易，是一种“零和游戏”。</p></li><li><p>你是想要一个正确的解释呢，还是想要一个让自己感觉舒服的解释？<br>正确的解释，会引发你下一步正确的选择和行动。让自己舒服却肯定不正确的解释，除了让你短暂舒服之外，因为它不是正确的，所以必然只能带来各种“出人意料”的副作用……你到底要哪一个解释？<br>正确的解释很简单：<br><font color="red">我们买入的时机错了</font><br>牛市的时候，鸡犬升天，多差的标的，都有可能持续暴涨；熊市的时候，万马齐喑，有时候好的资产反倒是跌得更狠……</p></li><li><p>为什么在股市中或者网络中普遍存在对骂一声“傻X”的现象呢？<br>因为他们认为这是一个“零和游戏”，所以：<br>a. 两个人中必然有一个是傻X；<br>b. 我这么聪明，所以傻X只能是你！</p></li></ul><p>一切的礼貌与修养，本质上都是深入思考的产物，跟说不说脏话没有关系。</p><p>千万不要以为，正在谈论“价值投资”的人，就是以“价值投资”作为行动与判断依据的人。若是常被表现所迷惑，你的交易成绩只能很差很差。</p><p>成功的交易者永远只是极少数，他们所具备的共同特征就是，他们不为表象所动，他们喜欢探究表现之下的实质。</p><ul><li><p>进入交易市场后，一冲进来不管三七二十一就拼命买买买，通常是被套的“韭菜”。</p></li><li><p>绝大多数人之所以正在讨论“价值投资”，是因为他们已然“被套住”了——这才是实质。这也是为什么有那么多人喜欢讨论“价值投资”的根本原因。</p></li><li><p>“研究透价值所在之后决定是否买卖”和“不管三七二十一先下手之后发现不对再去研究价值”有着天壤之别。</p></li><li><p>很有意思的现象：聪明和愚蠢，竟然不是被天生因素所决定，决定它们的竟然只不过是“顺序”……这和下棋一样，先走什么后走什么，最终决定输赢。这个顺序有其他的称呼，比如：“策略”、“算法”……</p></li><li><p>那些盲目相信“价值投资”的人，只能为自己的错误理解、错误决策默默买单。</p></li><li><p>每一套市面上的投资理论都只能解释一小部分的世界。</p></li><li><p>韭菜缺的不是耐心，缺乏的是实力，所以解决办法是提高自己的实力。那么什么是实力：长期稳定的低成本现金流。<br>无论是低息募资或者有场外赚钱的能力，对于大众来说，低成本募资基本上来说是不可能的，所以只能提高自己场外赚钱的能力。</p></li><li><p>仓位控制：永远要保留一定比例或者一定数量的现金，至于比例是多少，数量是多少，没有定量，因人而异，靠自己琢磨。</p></li><li><p>喜欢冒险的最终都是韭菜<br>冒险在都市传说中经常与“勇敢”混为一谈，在交易市场中这种混淆往往是致命的。优秀的、成功的交易者，最终都是风险厌恶者（这点很容易理解，没有人希望自己的钱袋子少钱）<br>能不冒险绝不冒险<br>即便是必须冒险的时候，也要让傻瓜们冒险，自己在一旁通过观察获得经验。也就是“送死”的事情不要身先士卒。</p></li><li><p>use other people’s money!(用别人的钱！)</p></li><li><p>Watch other people taking risks!（盯着别人冒险！）</p></li><li><p>思考正确的结论真的很难，因为有时候“正确的结论”看起来是那么邪恶，即便在最深处闪闪发光。</p></li><li><p>还有另外一些东西，甚至不是“冒险”，就是找死。比如，借钱冲进交易市场，比如，加上杠杆，再比如，在没有专业技能的情况下去玩期货。</p></li><li><p>计算风险成本要考虑很多因素，你的实力最重要，然后才是回报风险比。</p></li><li><p>TODO：<font color="red">止损线如何设置</font>，这个是需要学习的部分</p></li><li><p>越是短期的预测，越接近于抛硬币；越是长期的预测，越容易接近真实的逻辑推断……所以，降低交易频次的本质，是拒绝抛硬币，坚持逻辑推断。</p></li><li><p>“韭菜”都是冲动的，冲进交易市场，不阅读，不思考，不学习，他们之所以一冲进来就“买买买”，理由非常简单，“别人已经赚到钱了！”<br>被套之后才开始研究“价值投资”的，都是善良的韭菜，因为他们起码还在“默默地承担自己错误决策所带来的损失”，而后希望通过“学习”改善自己的遭遇。<br>更极端的“韭菜”，其实是更加常见的，一般都是要“维权”的！他们要“讨个说法”，讨一个让自己舒服一点的说法。<br>举个例子，今年小米上市，很多人高位接盘被套，他们都把脏水泼在了雷军的身上，这种人就是不折不扣的韭菜。他们完全没有为自己的决策和行为负责的能力。<br>更狠的韭菜是，他们知道自己“被隔”了，所以决定要坚持到“自己能割别人”，在这个过程中，若是谁竟然戳穿了真相，妨碍了“自己将要割韭菜的机会”，他就跟谁拼命。</p></li><li><p>我要是在那里卖这里买就好了！！！<br>所有的韭菜都有这种幻觉。每天都在盯着K线图，不断地在YY：<br>“唉，我要是在那里卖出（瞅着某个价格高点），然后在这里买入（目光挪到某个价格低点）……就好了”<br>“……就好了”，这个是个典型的韭菜句型，人们想要摆脱尴尬的时候所使用的句型。</p></li><li><p>作为交易市场中的一份子，你不大可能在最高点卖出，也很难在最低点买入……最高点和最低点都是因为一小部分交易者的“冲动”造成的</p></li><li><p>回报风险比<br>$$ 回报风险比 = \dfrac{可能的回报}{可能的风险}$$<br>从上面的公式可以看出，想要提高回报风险比，要么提高可能的回报，要么降低可能的风险。<br>减小分母的可行手段：<br>a. 调整止损线，降低自己的风险承担<br>b. 降低每次的交易金额在总资金的占比<br>c. 提高自己场外赚钱的能力（或者募资能力）<br>加大分子的可行手段：<br>a. 选择更为优质的交易标的<br>b. 选择更佳的交易时机<br>c. 放长持有时间</p></li><li><p>学任何东西都是为了“用得上”。<br>学着，但不着急用，等够用了再说……<br>然而，总有一些可以“现学现用”的有效技能。善于学习的人，其实就是善于辨别技能的这方面属性，他们会判断什么东西要慢慢磨练，什么东西要迅速上手，迅速实践。<br>“进场之后，不要动，看上一年之后再动手买。”<br>“只买交易量最大的那么一两个或者两三个标的。”</p></li><li><p>Fear of Missing Out，缩写FOMO，对丧失机会的极度恐惧。<br>越是缺乏机会的人越是容易被这样的句式煽动。</p></li><li><p>孤独是成功交易者最宝贵的品质<br>孤独地交易<br>高手们不重视“正确”，因为谁都可以正确，这并不是什么太难的事情。真正难的事情是，你不仅正确，还与众不同地正确。“特立独行且正确”，才可能产生巨大的交易价值。<br>听大多数人的话，参考少数人的意见，自己做决定。<br>听的意思是听听就够了，毕竟交易的操作是自己来做的，所以交易的决定也一定要自己来做。你必须，也只能为自己的决策负责。<br>独处是促进生产力的最佳方式之一。</p></li><li><p>失败并不可怕，可怕的是面对失败无能为力。</p></li><li><p>控制自己是天下最难的事情，最难过的是想到那些“你自己明明知道应该怎么做却事实上没有那么做”的情节，越是简单的原理越是难以遵守。</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 投资 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《java8实战》笔记</title>
      <link href="/8294.html"/>
      <url>/8294.html</url>
      
        <content type="html"><![CDATA[<h1 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h1><h2 id="什么是lambda表达式"><a href="#什么是lambda表达式" class="headerlink" title="什么是lambda表达式"></a>什么是lambda表达式</h2><p>我们可以吧lambda表达式理解为简洁地表示可传递的匿名函数的一种方式：它没有名称，但是有<code>参数列表</code>、<code>函数主体</code>、<code>返回类型</code>，可能还有一个<code>可以抛出的异常列表</code>。</p><a id="more"></a><p>从上面的定义来看，lambda表达式有如下特性：</p><ul><li>匿名——它不像普通的方法那样有一个明确的名称：写得少却想得多。</li><li>函数——lambda函数不像方法那样属于某个特定的类。但是和方法一样，lambda有参数列表、函数主题、返回类型，还有可能会抛出异常。</li><li>传递——lambda表达式可以作为参数传递给方法或者存储变量中。</li><li>简洁——无需像匿名类那样写很多的模板代码。</li></ul><p><code>一定要记住的一点是，lambda表达式是函数，在代码里面如果看到一个变量=lambda表达式，表示的意思是，这个变量是一个函数</code></p><p>来个例子：<br><img src="https://blog-1257857643.cos.ap-beijing.myqcloud.com/blog/15402270083079.jpg" alt=""></p><p>从上图可以看出，lambda表达式有三个部分：</p><ul><li>参数列表</li><li>箭头</li><li>lambda主体</li></ul><h2 id="在哪里使用以及如何使用"><a href="#在哪里使用以及如何使用" class="headerlink" title="在哪里使用以及如何使用"></a>在哪里使用以及如何使用</h2><p>在函数式接口上使用lambda表达式。<br>什么是函数式接口呢？<br>函数式接口就是只定义了一个抽象方法的接口(有多余的继承方法也是不被允许的)。<br>现在的函数式接口都加上了<code>@FunctionalInterface</code>注解，</p><p>用函数式接口可以干什么呢？<br>lambda表达式允许你直接以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例（具体来说，函数式接口一个具体实现的实例）。<br>用匿名内部类也可以完成同样的事情，只不过要分为两步，首先需要提供一个实现，然后再直接内联将它实例化。<br><img src="https://blog-1257857643.cos.ap-beijing.myqcloud.com/blog/15402270964036.jpg" alt=""></p><p>所以，lambda表达式到底是什么呢？lambda表达式也是实例化的对象，不过是是函数式接口的抽象实现并实例化的对象。</p><p>函数描述符<br>函数式接口的抽闲方法的签名基本上就是lambda表达式的签名。我们将这种抽象方法叫做函数描述符。</p><p>如何把lambda付诸实践</p><ul><li>记得行为参数化</li><li>使用函数式接口来传递行为</li><li>执行一个行为</li><li>传递lambda</li></ul><p>装箱：自动将原始类型转换为对应的引用类型的机制。<br>拆箱：将引用类型转换为对应的原始类型。</p><p>使用局部变量<br>lambda表达式允许使用自由变量（不是参数，而是在外层作用域中定义的变量，从这个意义上来说，就是闭包）<br>在使用局部变量的时候有限制，实例变量存储在堆中，而局部变量则保存在栈上。如果lambda可以直接访问局部变量，而且是在同一个线程中使用的，则使用lambda的线程，可能会在分配该变量的线程将这个变量收回之后去访问这个变量，这个时候就产生异常。<br>那么这个限制是什么：局部变量必须显式声明为final。</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>请注意，任何函数式接口都不允许抛出受检异常（Checked Exception）。如果你需要lambda表达式抛出异常，有两种办法：顶一个自己的函数式接口，并声明受检异常，或者把lambda表达式包裹在一个try/catch块中。</p><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p><img src="https://blog-1257857643.cos.ap-beijing.myqcloud.com/blog/15402271196847.jpg" alt=""></p><p>方法引用可以看做仅仅调用特定方法的lambda的一种快捷写法。<br>基本思想：如果一个lambda代表的只是“直接调用这个方法”，那最好还是用名称来调用它，而不是去描述如何调用它。<br>事实上，在我看来方法引用就是实现与调用分离。回想一下前面说的，lambda表达式是函数式接口的实现并实例化，这里面就是两步，第一是实现，第二是实例化。</p><p>如何构建方法引用<br>有三类：</p><ul><li>指向静态方法的方法引用</li><li>指向任意类型实例方法的方法引用</li><li>指向现有对象的实例方法的方法引用</li></ul><h2 id="复合lambda表达的有用方法"><a href="#复合lambda表达的有用方法" class="headerlink" title="复合lambda表达的有用方法"></a>复合lambda表达的有用方法</h2><ul><li>比较器复合<br>对库存进行排序，比较苹果的重量。<br><img src="https://blog-1257857643.cos.ap-beijing.myqcloud.com/blog/15402271468081.jpg" alt=""><br>逆序比较<br><img src="https://blog-1257857643.cos.ap-beijing.myqcloud.com/blog/15402271623499.jpg" alt=""></li></ul><p>比较器链<br><img src="https://blog-1257857643.cos.ap-beijing.myqcloud.com/blog/15402271772457.jpg" alt=""></p><ul><li>谓词复合<br>谓词接口包括三个方法：negate、and和or，咱们可以重用已有的Predicate来创建更加复杂的谓词。<br><img src="https://blog-1257857643.cos.ap-beijing.myqcloud.com/blog/15402271958347.jpg" alt=""></li></ul><ul><li>函数复合<br>Function接口所代表的lambda表达式可以复合起来，Function接口为此配了andThen和compose两个默认的方法。<br>比如f和g都是Function的两个实例<br>f.andThen(g) 表示 先执行f后执行g，数学上的表达式是g(f(x)) 其中x是参数<br>f.compose(g) 表示 先执行g后执行f，数学上的表达式是f(g(x))</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>lambda表达式可以理解为一种匿名函数：没有名称，但是有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常列表</li><li>lambda表达式让你可以简洁地传递代码</li><li>只有在接受函数式接口的地方才可以使用lambda表达式</li><li>lambda表达式允许你直接内联，为函数式接口的抽象方法提供实现，并且将整个表达式作为函数式接口的一个实例。</li><li>Java8 自带一些常用的函数式接口，放在<code>java.util.function</code>包中。</li><li>环绕执行模式（即在方法所必须的代码中间，你需要执行点什么操作，比如资源分配和清理）可以配合lambda提高灵活性和可重用性。</li><li>lambda表达式所需要代表的类型称之为目标类型</li><li>方法引用让你重复使用现有的方法实现并直接传递他们</li><li>Comparator、Predicate和Function等函数式接口都有几个可以用来结合lambda表达式的默认方法。</li></ul><h1 id="函数式数据处理"><a href="#函数式数据处理" class="headerlink" title="函数式数据处理"></a>函数式数据处理</h1><p>集合是 Java 中使用最多的 API。要是没有集合，我们的开发还能做什么呢？几乎每个Java应用程序都会制造和处理集合。</p><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>流是Java8 的新功能特性，它允许你以声明性方式处理数据集合（通过查询语句来表达，而不不是临时编写一个实现）。<br>流还可以透明地并行处理，你无需写任何多线程代码。<br>用一个例子来带入Stream的用法：<br><img src="https://blog-1257857643.cos.ap-beijing.myqcloud.com/blog/15402272177597.jpg" alt=""></p><p><img src="https://blog-1257857643.cos.ap-beijing.myqcloud.com/blog/15402272313419.jpg" alt=""></p><p>后续会说明调用parallelStream方法的时候到底发生了什么？用了多少个线程？对性能有多大的提升？</p><p>从上面的例子可以看到几个好处：</p><ul><li>代码是以声明式方式编写：说明想要完成什么（筛选热量低的菜肴）而不是说明如何实现一个操作（大量的循环和控制语句）。这种方法加上行为参数化可以轻松应对变化的需要。</li><li>可以把几个基础操作链接起来，表达复杂的数据处理流水线（在filter后面接上sorted、map和collect操作），同时保持代码清晰可读。</li></ul><p><img src="https://blog-1257857643.cos.ap-beijing.myqcloud.com/blog/15402272744073.jpg" alt=""></p><p>将流操作链接起来构成流的流水线<br>总结一下，Java8 中的Stream API可以让你写出这样的代码：</p><ul><li>声明性——更简洁，更易读</li><li>可复合——更灵活</li><li>可并行——性能更好</li></ul><h3 id="流简介"><a href="#流简介" class="headerlink" title="流简介"></a>流简介</h3><p>Java 8中的集合支持一个新的Stream方法，它会返回一个流(接口定义在java.util.stream.Stream中)。<br>流到底是什么？简短的定义就是“从支持数据处理操作的源生成的元素序列”。</p><ul><li>元素序列<br>就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序值。<br>因为集合是数据结构，所以它的主要目的是以特定的时间、空间复杂度存储和访问元素。但是流的目的在于表达计算，集合讲的是数据，流讲的是计算。</li><li>源<br>流会使用一个提供数据的源</li><li>数据处理操作<br>流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中常见操作，例如：filter、map、reduce、find、match、sort、group by等。<br>注意：流操作可以顺序执行，也可以并行执行。</li><li>流水线<br>很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线。<br>流水线的操作可以看作对数据源进行数据库式查询。</li><li>内部迭代<br>与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的。</li></ul><p>eg：查找热量最高的三道菜的菜名。<br><img src="https://blog-1257857643.cos.ap-beijing.myqcloud.com/blog/15402272870949.jpg" alt=""></p><p>filter——接受lambda，从流中排除某些元素<br>map——接受一个lambda，将元素转换成其他形式或者提取信息。<br>limit——截断流，使其元素不超过给定数量<br>collect——将流转换为其他形式</p><h3 id="流与集合"><a href="#流与集合" class="headerlink" title="流与集合"></a>流与集合</h3><blockquote><p>粗略来说，集合与流之间的差异就在于什么时候进行计算。集合是一个内存中的数据结构，它包含数据结构中目前所有的值——集合中的每个元素都得先算出来才能添加到集合中。相比之下，流则是在概念上固定的数据结构（你不能添加或者删除元素），其元素是按需计算的。</p></blockquote><ul><li>只能遍历一次<br>和迭代器类似，流只能遍历一次，遍历完以后，流就被消费掉了。如果需要再次使用的话，需要重新遍历流。</li><li>内部迭代与外部迭代<br><img src="https://blog-1257857643.cos.ap-beijing.myqcloud.com/blog/15402273135076.jpg" alt=""></li></ul><h3 id="流操作"><a href="#流操作" class="headerlink" title="流操作"></a>流操作</h3><p>流操作有两类：中间操作与终端操作。<br>中间操作：返回的是流<br>终端操作：从流的流水线中生成结果，其结果不是流。</p><h3 id="流使用"><a href="#流使用" class="headerlink" title="流使用"></a>流使用</h3><p>流的使用包括三件事情：</p><ul><li>一个数据源来执行查询；</li><li>一个中间操作链，形成一条流的流水线；</li><li>一个终端操作，执行流水线，并能生成结果。</li></ul><p>流的流水线类似于构建器模式，在构建器模式中有一个调用链用来设置一套配置，接着是调用built方法。<br><img src="https://blog-1257857643.cos.ap-beijing.myqcloud.com/blog/15402274077891.jpg" alt=""><br><img src="https://blog-1257857643.cos.ap-beijing.myqcloud.com/blog/15402274228294.jpg" alt=""></p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li>流是“从支持数据处理操作的源生成的一系列元素”。</li><li>流利用内部迭代：迭代通过filter、map、sorted等操作被抽象掉了。</li><li>流操作有两类</li><li>中间操作可以链接在一起，形成流水线</li><li>流中的元素是按需计算的</li><li>流每次只能遍历一次</li></ul><h2 id="使用流"><a href="#使用流" class="headerlink" title="使用流"></a>使用流</h2><h3 id="筛选与切片"><a href="#筛选与切片" class="headerlink" title="筛选与切片"></a>筛选与切片</h3><p>用谓词筛选，filter方法，该操作接受一个谓词（一个返回boolean的函数）作为参数，并返回一个包括所有符合谓词的元素的流。<br>流还支持一个distinct方法，用来过滤重复的元素。<br>limit方法用来截断流<br>skip方法用来跳过元素</p><p><img src="https://blog-1257857643.cos.ap-beijing.myqcloud.com/blog/15402274423523.jpg" alt=""></p><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>一个非常常见的数据处理套路就是从某些对象中选择信息。<br>map方法，接受一个函数作为参数，这个函数会被应用到每个元素上，并将其映射成一个新的元素（其实就是转换，但是不会改变原序列里面的值）</p><ul><li>流的扁平化<br>flatmap 方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个流。<h3 id="查找与匹配"><a href="#查找与匹配" class="headerlink" title="查找与匹配"></a>查找与匹配</h3>anyMatch 检查谓词是否至少匹配一个元素<br>allMatch 方法检查谓词是否匹配所有元素<br>findAny 方法返回当前六中的任意元素<br>findFirst 方法查找第一个元素<h3 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h3>将流中的所有元素反复结合起来，得到一个值，这样的操作叫做归约操作（将流归约成一个值）。<br>reduce方法</li></ul><p>map和reduce的连接通常称为map-reduce模式，很容易并行化。</p><p><img src="https://blog-1257857643.cos.ap-beijing.myqcloud.com/blog/15402274550455.jpg" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《奥马哈之雾》读书笔记</title>
      <link href="/56009.html"/>
      <url>/56009.html</url>
      
        <content type="html"><![CDATA[<h3 id="七层塔"><a href="#七层塔" class="headerlink" title="七层塔"></a>七层塔</h3><blockquote><p>塔层1：将股票看做生意的一部分<br>塔层2：正确对待股价波动<br>塔层3：安全边际<br>塔层4：对“超级明星”的集中投资<br>塔层5：选择性逆向操作<br>塔层6：有所不为<br>塔层7：低摩擦成本下的复利追求</p></blockquote><p>四把尺（四只脚）<br>我们所希望的投资对象是：<br>一是我们所了解的；<br>二是具有长期的远景；<br>三是由德才兼备的人来经营；<br>四是有非常吸引人的价格。</p><p>重要的正确投资奠基石</p><blockquote><p>把股票当做许多细小的商业部分<br>把价格波动当做朋友而不是敌人<br>在买入价格上留有充足的安全边际</p></blockquote><p>关于安全边际<br>格雷厄姆提出的安全边际准则是以对公司内在价值的度量为基本前提的<br>后台巴菲特把他老师的纯量化（或纯财务）度量改成了以定性为主，定量为辅的评估模式。</p><p>==TODO：什么是定量，什么是定性？定量考察哪些指标，定性考察哪些方向==</p><p>安全边际的一般性潜台词：相对于公司较为稳定或没那么悲观的基本资产或基本情况市场由于出现非理性的过度反应，而给出了过低的估值。</p><p>通用食品收购获利的因素：</p><ol><li>便宜的买进价格</li><li>一个优秀的公司</li><li>一群能干且注重股东权益的管理阶层</li><li>愿意出高价的买主</li></ol><h3 id="龟兔赛跑"><a href="#龟兔赛跑" class="headerlink" title="龟兔赛跑"></a>龟兔赛跑</h3><p>一个真正的企业投资人应当忘记股票价格的短期变化，把主要注意力集中于公司的经营层面；即使你的目标是获取资本买入与卖出之间的差价，也应当以5-10年为一个周期来规划你的投资。<br>当然不仅仅是在投资领域，在我们生活中的其他方面，看待任何事情时，其视角都不应该太过于短期化。</p><p>每股税前利润<br>巴菲特一直重“长期投资回报”而轻“年度经营回报”。<br>当一只股票卖出时，其资本利得计入当年损益，因此，在回报率保持不变的前提下，频繁换股就会同时导致“经营回报”的增加和“投资回报”的减少。–摩擦成本<br>由于巴菲特的经营目标是伯克希尔公司股东价值的长期最大化，而不是年度账面利润的提升，因此选择“现在我们宁愿留在原处不动”的投资策略。</p><p>短期利润与长期回报之间的取舍：</p><blockquote><p>个人一再重申：已实现的资本利得对于分析伯克希尔公司来说，一点儿用处都没有，我们账上拥有大量的未实现资本利得，何时该将其实现，其考量点与某些特定日期的财务报表完全没有关联。</p></blockquote><p>关于四只脚的再论述<br>巴菲特的四只脚投资标准：</p><ol><li>我们能够了解 （<code>涉及对产业和产品繁简的判断</code>）</li><li>良好的经济前景 （<code>涉及对“城堡”是否美丽，“护城河”是否宽广的判断</code>）</li><li>德才兼备的管理人（<code>涉及对经营者道德品质和领导才能的判断</code>）</li><li>吸引人的价格（<code>涉及对一家企业价值与价格是否匹配的判断</code>）</li></ol><p>卡片打洞思想：</p><blockquote><p>当你们离开学校以后，可以做一张印有20个圈的卡片，每次你们做完一个投资决策时，就在其中一个圈上打一个洞。那些打洞较少的人将会变得富有，原因在于如果你总能为大的想法而节省的话，你永远不会打光所有20个洞。</p></blockquote><p>如果用一句话来概括巴菲特的投资特质的话应该是“一个企业投资者”，企业投资与长期投资就是一个硬币的两面，不可分割。</p><h3 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h3><p>纵观巴菲特作为职业投资人的经理，我们发觉他能成功的原因之一在于他对所有可能涉足的投资领域都先后为自己划出了有所不为的边界：</p><blockquote><p>告诉我会死在哪里，我就永远不会去那里。</p></blockquote><p>巴菲特的四只脚理论中，排在首位的就是能力边界的问题。<br>首先。“能力边界”<br>“只要一波大浪起来就可以撑起所有的船只” – 肯尼迪</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 投资 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何选择成长股-读书笔记</title>
      <link href="/50275.html"/>
      <url>/50275.html</url>
      
        <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在摘录的同时会记录我的思考。</p><a id="more"></a><h2 id="寻找优良普通股的15点原则"><a href="#寻找优良普通股的15点原则" class="headerlink" title="寻找优良普通股的15点原则"></a>寻找优良普通股的15点原则</h2><h3 id="原则1：这家公司的产品或者服务有没有充分的市场潜力，至少几年内营业额能否大幅成长？"><a href="#原则1：这家公司的产品或者服务有没有充分的市场潜力，至少几年内营业额能否大幅成长？" class="headerlink" title="原则1：这家公司的产品或者服务有没有充分的市场潜力，至少几年内营业额能否大幅成长？"></a>原则1：这家公司的产品或者服务有没有充分的市场潜力，至少几年内营业额能否大幅成长？</h3><p>那些数十年来一直保持着惊人的增长速度的公司可以分为两组，一组名叫“由于幸运而有能力”，另一组称为“由于有能力而幸运”。<br>对于这两组公司来说管理层能力的高效理性都是必不可少的，没有哪个公司仅仅由于幸运就能在长时间内持续增长。它必须拥有和继续保持商业技能的高效理想，否则就不能利用它的好运气来抵抗竞争对手的侵袭。<br>无论是哪种类型的公司，投资者必须关注管理层目前和今后是否有很强大的管理能力；如果没有的话，销售额就不会再继续增长。<br>如果公司拥有杰出的管理层，所处行业又正在接受技术的转变和发展，那么管理层有没有足够能力处理公司事务，以便在未来变革中出现的和最初设想的销售额曲线是否为同一形态，敏锐的投资者需要对此保持警惕。</p><h3 id="原则2：为了进一步提高总体销售水平，发现新的产品增长点，管理层是不是决心继续开发新产品或新工艺？"><a href="#原则2：为了进一步提高总体销售水平，发现新的产品增长点，管理层是不是决心继续开发新产品或新工艺？" class="headerlink" title="原则2：为了进一步提高总体销售水平，发现新的产品增长点，管理层是不是决心继续开发新产品或新工艺？"></a>原则2：为了进一步提高总体销售水平，发现新的产品增长点，管理层是不是决心继续开发新产品或新工艺？</h3><p>第一点原则是关于事实的问题，即对公司现有产品的潜在的销售额增长程度作出评价。<br>第二点原则是关于管理层态度的问题。公司现在是否认识到，现有市场的潜能已经几乎开发完毕，以及可能在未来的某一时间进一步发展新市场？只有在第一点原则上得到较高评价，同时以赞成的态度对待第二点原则，公司才可能获得很大的投资收益。</p><h3 id="原则3：考虑到公司规模的大小，公司在研究和发展上付出的努力是否有效？"><a href="#原则3：考虑到公司规模的大小，公司在研究和发展上付出的努力是否有效？" class="headerlink" title="原则3：考虑到公司规模的大小，公司在研究和发展上付出的努力是否有效？"></a>原则3：考虑到公司规模的大小，公司在研究和发展上付出的努力是否有效？</h3><h3 id="原则4：公司是否拥有高于平均水平的销售团队？"><a href="#原则4：公司是否拥有高于平均水平的销售团队？" class="headerlink" title="原则4：公司是否拥有高于平均水平的销售团队？"></a>原则4：公司是否拥有高于平均水平的销售团队？</h3><h3 id="原则5：公司是否具备有价值的利润率？"><a href="#原则5：公司是否具备有价值的利润率？" class="headerlink" title="原则5：公司是否具备有价值的利润率？"></a>原则5：公司是否具备有价值的利润率？</h3><p>横向对比与纵向对比结合</p><h3 id="原则6：公司正在为维持或者增加利润率而做些什么？"><a href="#原则6：公司正在为维持或者增加利润率而做些什么？" class="headerlink" title="原则6：公司正在为维持或者增加利润率而做些什么？"></a>原则6：公司正在为维持或者增加利润率而做些什么？</h3><p>买股票买的不是过去也不是现在，还是未来，我们看中的是将来的利润和利润率，如果当前公司的利润不好，那我们将要看这家公司正在做什么样的努力在改变这种低迷的颓势，如果这家公司如日中天，那我们要看这家公司在做什么保持这种势头，看这种优势有没有正在被拉大，利润和利润率有没有稳步上升。</p><h3 id="原则7：公司是否具备出色的的劳动和人事关系？"><a href="#原则7：公司是否具备出色的的劳动和人事关系？" class="headerlink" title="原则7：公司是否具备出色的的劳动和人事关系？"></a>原则7：公司是否具备出色的的劳动和人事关系？</h3><p>这个是说雇员与雇主之间的关系</p><h3 id="原则8：公司是否具有良好的行政关系？"><a href="#原则8：公司是否具有良好的行政关系？" class="headerlink" title="原则8：公司是否具有良好的行政关系？"></a>原则8：公司是否具有良好的行政关系？</h3><p>这个是说高管之间的相处问题</p><h3 id="原则9：公司的管理是否有层次？"><a href="#原则9：公司的管理是否有层次？" class="headerlink" title="原则9：公司的管理是否有层次？"></a>原则9：公司的管理是否有层次？</h3><p>如果其他因素合适的话，实际上独裁式管理的小公司可以把生意做得相当好，并且在很多年内可以成为很好的投资对象。</p><p>管理者的授权是很重要的一点。</p><h3 id="原则10：公司在成本分析和财务控制方面做得有多好？"><a href="#原则10：公司在成本分析和财务控制方面做得有多好？" class="headerlink" title="原则10：公司在成本分析和财务控制方面做得有多好？"></a>原则10：公司在成本分析和财务控制方面做得有多好？</h3><h3 id="原则11：关于竞争力的强弱，公司是否在商业的其他方面，尤其在行业内的领域为投资者提供重要的线索？"><a href="#原则11：关于竞争力的强弱，公司是否在商业的其他方面，尤其在行业内的领域为投资者提供重要的线索？" class="headerlink" title="原则11：关于竞争力的强弱，公司是否在商业的其他方面，尤其在行业内的领域为投资者提供重要的线索？"></a>原则11：关于竞争力的强弱，公司是否在商业的其他方面，尤其在行业内的领域为投资者提供重要的线索？</h3><h3 id="原则12：公司是否拥有短期或者长期的利润前景？"><a href="#原则12：公司是否拥有短期或者长期的利润前景？" class="headerlink" title="原则12：公司是否拥有短期或者长期的利润前景？"></a>原则12：公司是否拥有短期或者长期的利润前景？</h3><h3 id="原则13：在可预见的未来，公司的增长是否需要足够的股权融资，以保证更多发行在外的股份能够在很大程度上通过预期的增长来抵消现有股东的利益？"><a href="#原则13：在可预见的未来，公司的增长是否需要足够的股权融资，以保证更多发行在外的股份能够在很大程度上通过预期的增长来抵消现有股东的利益？" class="headerlink" title="原则13：在可预见的未来，公司的增长是否需要足够的股权融资，以保证更多发行在外的股份能够在很大程度上通过预期的增长来抵消现有股东的利益？"></a>原则13：在可预见的未来，公司的增长是否需要足够的股权融资，以保证更多发行在外的股份能够在很大程度上通过预期的增长来抵消现有股东的利益？</h3><h3 id="原则14：管理阶层是不是只向投资人报喜不报忧？诸事顺昌时口沫横飞，有问题或叫人失望的事情发生时，则“三缄其口”？"><a href="#原则14：管理阶层是不是只向投资人报喜不报忧？诸事顺昌时口沫横飞，有问题或叫人失望的事情发生时，则“三缄其口”？" class="headerlink" title="原则14：管理阶层是不是只向投资人报喜不报忧？诸事顺昌时口沫横飞，有问题或叫人失望的事情发生时，则“三缄其口”？"></a>原则14：管理阶层是不是只向投资人报喜不报忧？诸事顺昌时口沫横飞，有问题或叫人失望的事情发生时，则“三缄其口”？</h3><h3 id="原则15：这家公司管理层的诚信正直态度是否毋庸置疑？"><a href="#原则15：这家公司管理层的诚信正直态度是否毋庸置疑？" class="headerlink" title="原则15：这家公司管理层的诚信正直态度是否毋庸置疑？"></a>原则15：这家公司管理层的诚信正直态度是否毋庸置疑？</h3><h2 id="投资人“五不”原则"><a href="#投资人“五不”原则" class="headerlink" title="投资人“五不”原则"></a>投资人“五不”原则</h2><ol><li>不买处于创业阶段的公司。</li><li>不要因为一支好股票在“店头市场”交易，就弃之不顾。</li><li>不要因为你喜欢某公司年报的“格调”，就去买该公司的股票。</li><li>不要以为一公司的本益比（市盈率）高，便表示未来的盈余成长已大致反映在价格上。</li><li>不要锱铢必较。</li></ol><h2 id="投资人“另五不”原则"><a href="#投资人“另五不”原则" class="headerlink" title="投资人“另五不”原则"></a>投资人“另五不”原则</h2><ol><li>不要过度强调分散投资。</li><li>不要担心在战争阴影笼罩下买进股票。</li><li>不要忘了你的吉尔伯特和沙利文。</li><li>买进真正优秀的成长股时，除了考虑价格，不要忘了时机因素。</li><li>不要随波逐流。</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 投资 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见的经济学定律</title>
      <link href="/56118.html"/>
      <url>/56118.html</url>
      
        <content type="html"><![CDATA[<h2 id="马太效应"><a href="#马太效应" class="headerlink" title="马太效应"></a>马太效应</h2><p>《新约马太福音》中有这样一个故事，一个国王远行前，交给三个仆人每人一锭银子，吩咐他们：”你们去做生意，等我回来时，再来见我。”国王回来时，第一个仆人说：”主人，你交给我们的一锭银子，我已赚了10锭。”于是国王奖励他10座城邑。第二个仆人报告说：”主人，你给我的一锭银子，我已赚了5锭。”于是国王例奖励了他5座城邑。第三个仆人报告说：”主人，你给我的一锭银子，我一直包在手巾里存着，我怕丢失，一直没有拿出来。”于是国王命令将第三个仆人的一锭银子也赏给第一个仆人，并且说：”凡是少的，就连他所有的也要夺过来。凡是多的，还要给他，叫他多多益善。”</p><a id="more"></a><p>这就是马太效应。看看我们周围，就可以发现许多马太效应的例子。朋友多的人会借助频繁的交往得到更多的朋友；缺少朋友的人会一直孤独下去。金钱方面更是如此，即使投资回报率相同，一个比别人投资多10倍的人，收益也多10倍。这是个赢家通吃的社会，善用马太效应，赢家就是你。对企业经营发展而言，马太效应则告诉我们，要想在某一个领域保持优势，就必须在此领域迅速做大。当你成为某个领域的领头羊的时候，即使投资回报率相同，你也能更轻易的获得比弱小的同行更大的收益。而若没有实力迅速在某个领域做大，就要不停地寻找新的发展领域，才能保证获得较好的回报。</p><h2 id="手表定理"><a href="#手表定理" class="headerlink" title="手表定理"></a>手表定理</h2><p>手表定理是指一个人有一只表时，可以知道几点钟，而当他同时拥有两只表时却无法确定。两只表并不能告诉一个人更准确的时间，反而会让看表的人失去对准确时间的信心。你要做的就是选择其中较信赖的一只，尽力校准它，并以此作为你的标准，听从它的指引行事。记住尼采的话：”兄弟，如果你是幸运的，你只需有一种道德而不要贪多，这样，你过桥更容易些。”如果每个人都”选择你所爱，爱你所选择”，无论成败都可以心安理得。然而，困扰很多人的是：他们被”两只表”弄得无所适从，心身交瘁，不知自己该信仰哪一个，还有人在环境、他人的压力下，违心选择了自己并不喜欢的道路，为此而郁郁终生，即使取得了受人瞩目的成就，也体会不到成功的快乐。<br>手表定理在企业经营管理方面给我们一种非常直观的启发，就是对同一个人或同一个组织的管理不能同时采用两种不同的方法，不能同时设置两个不同的目标。甚至每一个人不能由两个人来同时指挥，否则将使这个企业或这个人无所适从。手表定理所指的另一层含义在于每个人都不能同时挑选两种不同的价值观，否则，你的行为将陷于混乱。</p><h2 id="不值得定律"><a href="#不值得定律" class="headerlink" title="不值得定律"></a>不值得定律</h2><p>不值得定律最直观的表述是：不值得做的事情，就不值得做好，这个定律似乎再简单不过了，但它的重要性却时时被人们疏忘。不值得定律反映出人们的一种心理，一个人如果从事的是一份自认为不值得做的事情，往往会保持冷嘲热讽，敷衍了事的态度。不仅成功率小，而且即使成功，也不会觉得有多大的成就感。哪些事值得做呢？一般而言，这取决于三个因素。<br>1、价值观。关于价值观我们已经谈了很多，只有符合我们价值观的事，我们才会满怀热情去做。<br>2、个性和气质。一个人如果做一份与他的个性气质完全背离的工作，他是很难做好的，如一个好交往的人成了档案员，或一个害羞者不得不每天和不同的人打交道。<br>3、现实的处境。同样一份工作，在不同的处境下去做，给我们的感受也是不同的。例如，在一家大公司，如果你最初做的是打杂跑腿的工作，你很可能认为是不值得的，可是，一旦你被提升为领班或部门经理，你就不会这样认为了。<br>总结一下，值得做的工作是：符合我们的价值观，适合我们的个性与气质，并能让我们看到期望。如果你的工作不具备这三个因素，你就要考虑换一个更合适的工作，并努力做好它。因此，对个人来说，应在多种可供选择的奋斗目标及价值观中挑选一种，然后为之而奋斗。”选择你所爱的，爱你所选择的”，才可能激发我们的奋斗毅力，也才可以心安理得。而对一个企业或组织来说，则要很好地分析员工的性格特性，合理分配工作，如让成就欲较强的职工单独或牵头来完成具有一定风险和难度的工作，并在其完成时给予定时的肯定和赞扬；让依附欲较强的职工更多地参加到某个团体XXXXX同工作；让权力欲较强的职工担任一个与之能力相适应的主管。同时要加强员工对企业目标的认同感，让员工感觉到自己所做的工作是值得的，这样才能激发职工的热情。</p><h2 id="彼得原理"><a href="#彼得原理" class="headerlink" title="彼得原理"></a>彼得原理</h2><p>彼得原理是美国学者劳伦斯·彼得在对组织中人员晋升的相关现象研究后得出的一个结论：在各种组织中，由于习惯于对在某个等级上称职的人员进行晋升提拔，因而雇员总是趋向于晋升到其不称职的地位。彼得原理有时也被称为”向上爬”原理。这种现象在现实生活中无处不在：一名称职的教授被提升为大学校长后无法胜任；一个优秀的运动员被提升为主管体育的官员，而无所作为。对一个组织而言，一旦组织中的相当部分人员被推到了其不称职的级别，就会造成组织的人浮于事，效率低下，导致平庸者出人头地，发展停滞。<br>因此，这就要求改变单纯的”根据贡献决定晋升”的企业员工晋升机制，不能因某个人在某一个岗位级别上干得很出色，就推断此人一定能够胜任更高一级的职务。要建立科学、合理的人员选聘机制，客观评价每一位职工的能力和水平，将职工安排到其可以胜任的岗位。不要把岗位晋升当成对职工的主要奖励方式，应建立更有效的奖励机制，更多地以加薪、休假等方式作为奖励手段。有时将一名职工晋升到一个其无法很好发挥才能的岗位，不仅不是对职工的奖励，反而使职工无法很好发挥才能，也给企业带来损失。对个人而言，虽然我们每个人都期待着不停地升职，但不要将往上爬作为自己的惟一动力。与其在一个无法完全胜任的岗位勉力支撑、无所适从，还不如找一个自己能游刃有余的岗位好好发挥自己的专长。</p><h2 id="零和游戏原理"><a href="#零和游戏原理" class="headerlink" title="零和游戏原理"></a>零和游戏原理</h2><p>当你看到两位对弈者时，你就可以说他们正在玩”零和游戏”。因为在大多数情况下，总会有一个赢，一个输，如果我们把获胜计算为得1分，而输棋为-1分，那么，这两人得分之和就是：1+（-1）=0。这正是”零和游戏”的基本内容：游戏者有输有赢，一方所赢正是另一方所输，游戏的总成绩永远是零。零和游戏原理之所以广受关注，主要是因为人们发现在社会的方方面面都能发现与”零和游戏”类似的局面，胜利者的光荣后面往往隐藏着失败者的辛酸和苦涩。从个人到国家，从政治到经济，似乎无不验证了世界正是一个巨大的”零和游戏”场。<br>这种理论认为，世界是一个封闭的系统，财富、资源、机遇都是有限的，个别人、个别地区和个别国家财富的增加必然意味着对其他人、其他地区和国家的掠夺，这是一个”邪恶进化论”式的弱肉强食的世界。但20世纪人类在经历了两次世界大战，经济的高速增长、科技进步、全球化以及日益严重的环境污染之后，”零和游戏”观念正逐渐被”双赢”观念所取代。人们开始认识到”利己”不一定要建立在”损人”的基础上。通过有效合作，皆大欢喜的结局是可能出现的。但从”零和游戏”走向”双赢”，要求各方要有真诚合作的精神和勇气，在合作中不要耍小聪明，不要总想占别人的小便宜，要遵守游戏规则，否则”双赢”的局面就不可能出现，最终吃亏的还是自己。</p><h2 id="华盛顿合作规律"><a href="#华盛顿合作规律" class="headerlink" title="华盛顿合作规律"></a>华盛顿合作规律</h2><p>华盛顿合作规律说的是：一个人敷衍了事，两个人互相推诿，三个人则永无成事之日。多少有点类似于我们”三个和尚”的故事。人与人的合作不是人力的简单相加，而是要复杂和微妙得多。在人与人的合作中，假定每个人的能力都为1，那么10个人的合作结果就有时比10大得多，有时甚至比1还要小。因为人不是静止的动物，而更像方向各异的能量，相推动时自然事半功倍，相互抵触时则一事无成。我们传统的管理理论中，对合作研究得并不多，最直观的反映就是，大多数管理制度和行业都是致力于减少人力的无谓消耗，而非利用组织提高人的效能。换言之，不妨说管理的主要目的不是让每个人做到最好，而是避免内耗过多。21世纪将是一个合作的时代，值得庆幸的是，越来越多的人已经认识到真诚合作的重要性，正在努力学习合作。邦尼人力定律：一个人一分钟可以挖一个洞，六十个人一秒种却挖不了一个洞。合作是一个问题，如何合作也是一个问题。</p><h2 id="酒与污水定律"><a href="#酒与污水定律" class="headerlink" title="酒与污水定律"></a>酒与污水定律</h2><p>酒与污水定律是指，如果把一匙酒倒进一桶污水中，你得到的是一桶污水；如果把一匙污水倒进一桶酒中，你得到的还是一桶污水。几乎在任何组织里，都存在几个难弄的人物，他们存在的目的似乎就是为了把事情搞糟。他们到处搬弄是非，传播流言、破坏组织内部的和谐。最糟糕的是，他们像果箱里的烂苹果，如果你不及时处理，它会迅速传染，把果箱里其它苹果也弄烂，”烂苹果”的可怕之处在于它那惊人的破坏力。一个正直能干的人进入一个混乱的部门可能会被吞没，而一个人无德无才者能很快将一个高效的部门变成一盘散沙。组织系统往往是脆弱的，是建立在相互理解、妥协和容忍的基础上的，它很容易被侵害、被毒化。破坏者能力非凡的另一个重要原因在于，破坏总比建设容易。一个能工巧匠花费时日精心制作的陶瓷器，一头驴子一秒钟就能毁坏掉。如果拥有再多的能工巧匠，也不会有多少像样的工作成果。如果你的组织里有这样的一头驴子，你应该马上把它清除掉；如果你无力这样做，你就应该把它拴起来。</p><h2 id="水桶定律"><a href="#水桶定律" class="headerlink" title="水桶定律"></a>水桶定律</h2><p>水桶定律是讲，一只水桶能装多少水，完全取决于它最短的那块木板。这就是说任何一个组织都可能面临的一个共同问题，即构成组织的各个部分往往决定了整个组织的水平。构成组织的各个部分往往是优劣不齐的，而劣质部分往往又决定整个组织的水平。”水桶定律”与”酒与污水定律”不同，后者讨论的是组织中的破坏力量，而”最短的木板”却是组织中有用的一个部分，只不过比其它部分差一些，你不能把它们当成烂苹果扔掉。强弱只是相对而言的，无法消除。问题在于你容忍这种弱点到什么程度。如果它严重到成为阻碍工作的瓶颈，就不得不有所动作。<br>如果你在一个组织中，你应该：<br>1、确保你不是最薄弱的部分；<br>2、避免或减少这一薄弱环节对你成功的影响；<br>3、如果不幸，你正处在这一环节中，你还可以采取有效的方法改进，或者转职去谋另一份工作。<br>水桶定律还有最新的解释，那就是水桶是侧放着的。因此最终，你的长板决定了你的装水量。<br>比如偏科，我们经常说不好，但是历史上偏科的奇才数不胜数。</p><h2 id="蘑菇管理"><a href="#蘑菇管理" class="headerlink" title="蘑菇管理"></a>蘑菇管理</h2><p>蘑菇管理是许多组织对待初出茅庐者的一种管理方法，初学者被置于阴暗的角落（不受重视的部门，或打杂跑腿的工作），浇上一头大粪（无端的批评、指责、代人受过），任其自生自灭（得不到必要的指导和提携）。相信很多人都有这样一段”蘑菇”的经历，但这不一定是什么坏事，尤其是当一切都刚刚开始的时候，当上几天”蘑菇”，能够消除我们很多不切实际的幻想，让我们更加接近现实，看问题也更加实际，而对一个组织而言，一般地新进的人员都是一视同仁，从起薪到工作都不会有大的差别。无论你是多么优秀的人才，在刚开始的时候都只能从最简单的事情做起，”蘑菇”的经历对于成长中的年轻人来说，就像蚕茧，是羽化前必须经历的一步。所以，如何高效率地走过生命中的这一段，从中尽可能吸取经验，成熟起来，并树立良好的值得信赖的个人形象，是每个刚入社会的年轻人必须面对的课题。</p><h2 id="奥卡姆剃刀定律"><a href="#奥卡姆剃刀定律" class="headerlink" title="奥卡姆剃刀定律"></a>奥卡姆剃刀定律</h2><p>如果你认为只有焦头烂额、忙忙碌碌地工作才可能取得成功，那么，你错了。事情总是朝着复杂的方向发展，复杂会造成浪费，而效能则来自于单纯。在你做过的事情中可能绝大部分是毫无意义的，真正有效的活动只是其中的一小部分，而它们通常隐含于繁杂的事物中。找到关键的部分，去掉多余的活动，成功并不那么复杂。<br>奥卡姆剃刀：如无必要，勿增实体。<br>12世纪，英国奥卡姆的威廉对无休无止的关于”共相”、”本质”之类的争吵感到厌倦，主张唯名论，只承认确实存在的东西，认为那些空洞无物的普遍性要领都是无用的累赘，应当被无情地”剃除”。他主张，”如无必要，勿增实体。”这就是常说的”奥卡姆剃刀”。这把剃刀曾使很多人感到威胁，被认为是异端邪说，威廉本人也受到伤害。然而，这并未损害这把刀的锋利，相反，经过数百年越来越快，并早已超越了原来狭窄的领域而具有广泛的、丰富的、深刻的意义。奥卡姆剃刀定律在企业管理中可进一步深化为简单与复杂定律：把事情变复杂很简单，把事情变简单很复杂。这个定律要求，我们在处理事情时，要把握事情的主要实质，把握主流，解决最根本的问题。尤其要顺应自然，不要把事情人为地复杂化，这样才能把事情处理好。</p><h2 id="二八法则"><a href="#二八法则" class="headerlink" title="二八法则"></a>二八法则</h2><p>你所完成的工作里80%的成果，来自于你20%的付出；而80%的付出，只换来20%的成果。</p><h2 id="鲶鱼效应"><a href="#鲶鱼效应" class="headerlink" title="鲶鱼效应"></a>鲶鱼效应</h2><p>鲶鱼效应是采取一种手段或措施，刺激一些企业活跃起来投入到市场中积极参与竞争，从而激活市场中的同行业企业。其实质是一种负激励，是激活员工队伍的奥秘。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 经济学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信公众号开发中控token服务</title>
      <link href="/54424.html"/>
      <url>/54424.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p>先推荐一个工具包：<br><a href="https://github.com/Wechat-Group/weixin-java-tools?utm_source=gold_browser_extension" target="_blank" rel="noopener">Wechat-Group/weixin-java-tools: 全能微信Java开发工具包，支持包括微信支付、开放平台、小程序、企业微信/企业号和公众号等的开发</a><br>以微信公众号开发为例，来说明我们所遇到的问题。<br>我们在进行微信公众号开发时，往往会拆分为多个服务，每个服务负责不同的功能，但是公众号的认证id和秘钥只有一套，这个时候如果每个服务都独自去生成access_token，就会浪费access_token的生成次数，以及会失效之前的token。这个时候需要一个独立服务来生成以及管理access_token，其余服务只需要去这个服务取token就行了。</p><a id="more"></a><p>我们在进行微信公众号开发时，微信公众号平台会给开发者ID和开发者密码，这两个东西是用来做认证的(生成access_token)。<br>我们在进行微信开发的时候，调用微信接口时，微信官方是需要认证的，如下图所示，认证的基础信息为开发者ID以及开发者密码，用这两个东西可进行认证。<br>官方是这样说的：</p><blockquote><p>access_token是公众号的全局唯一接口调用凭据，公众号调用各接口时都需使用access_token。开发者需要进行妥善保存。access_token的存储至少要保留512个字符空间。access_token的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的access_token失效。<br>公众平台的API调用所需的access_token的使用及生成方式说明：<br>1、建议公众号开发者使用中控服务器统一获取和刷新Access_token，其他业务逻辑服务器所使用的access_token均来自于该中控服务器，不应该各自去刷新，否则容易造成冲突，导致access_token覆盖而影响业务；<br>2、目前Access_token的有效期通过返回的expire_in来传达，目前是7200秒之内的值。中控服务器需要根据这个有效时间提前去刷新新access_token。在刷新过程中，中控服务器可对外继续输出的老access_token，此时公众平台后台会保证在5分钟内，新老access_token都可用，这保证了第三方业务的平滑过渡；<br>3、Access_token的有效时间可能会在未来有调整，所以中控服务器不仅需要内部定时主动刷新，还需要提供被动刷新access_token的接口，这样便于业务服务器在API调用获知access_token已超时的情况下，可以触发access_token的刷新流程。</p></blockquote><p>官方认证接口为：</p><pre><code>https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET</code></pre><h2 id="token中控服务器架构图"><a href="#token中控服务器架构图" class="headerlink" title="token中控服务器架构图"></a>token中控服务器架构图</h2><p>思路：业务服务每次在请求微信公众平台接口时，先去token中控服务取一下access_token，然后拿着这个token去微信公众平台访问其他接口，如果返回token失效，业务服务自己告诉中控服务新生成一个access_token，然后用这个新的acces_token重新去请求微信接口。</p><h2 id="如何实现token中控服务器？"><a href="#如何实现token中控服务器？" class="headerlink" title="如何实现token中控服务器？"></a>如何实现token中控服务器？</h2><p>引入jar包</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.github.binarywang&lt;/groupId&gt;    &lt;artifactId&gt;weixin-java-mp&lt;/artifactId&gt;    &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>设置一个web项目，只有这个项目有生成access_token的权限，也就是说只有这个项目有权去使用appId和appsecret调用access_token生成接口，其余服务调用这个服务生成access_token或者获取access_token。<br>中控服务提供两个接口：</p><ul><li>获取最新的access_token: 总是从redis中取出最新生成的access_token。</li><li>生成新的access_token接口：这个接口需要加锁，这把锁的失效时间应该小于5分钟，因为微信access_token生成接口，新的token生成以后，老的token会在5分钟后失效，但是如果此时又有一个人调用了生成token的服务，第一个token会立即失效。</li></ul><h2 id="封装SDK"><a href="#封装SDK" class="headerlink" title="封装SDK"></a>封装SDK</h2><p>业务方调用微信接口的流程，前面已经说清楚了，这里再重复一遍：</p><ul><li>先去中控服务取access_token。</li><li>拿着这个access_token去微信服务调用接口。</li><li>如果返回access_token失效，则进行重试。</li><li>重试的流程为：调用中控服务的生成新access_token的接口，拿着返回的新token去访问微信接口，业务方可以控制重试的次数为3次。</li></ul><p>如果每个业务方服务都把这逻辑实现一遍，那就太傻了，所以势必要对其进行封装成SDK。所幸weixin-java-tools这个jar包已经实现了大部分的功能，我们只需进行很小的改动就可以实现我们的逻辑，这里不对weixin-java-tools里面的代码做过多的解释，下面贴出实现方案：</p><pre class=" language-Java"><code class="language-Java">public class MyWxMpServiceImpl extends WxMpServiceHttpClientImpl {    private TokenClient tokenClient;    public MyWxMpServiceImpl(TokenClient tokenClient) {        this.tokenClient = tokenClient;    }    public String getAccessToken(boolean forceRefresh) throws WxErrorException {        Lock lock = this.getWxMpConfigStorage().getAccessTokenLock();        try {            lock.lock();            if (this.getWxMpConfigStorage().isAccessTokenExpired() || forceRefresh) {                String token = tokenClient.generateMpToken();                this.getWxMpConfigStorage().updateAccessToken(token, 100000);            }        } finally {            lock.unlock();        }        return this.getWxMpConfigStorage().getAccessToken();    }}</code></pre><p>新建一个类继承WxMpServiceHttpClientImpl，重写getAccessToken方法，之前的getAccessToken是去微信官方接口取access_token，这里改为token中控服务取token，其中TokenClient为对token中控服务调用的封装，这里依赖注入进来。</p><p>使用的代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> WxMpService <span class="token function">getWxMpService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        WxMpInMemoryConfigStorage configStorage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WxMpInMemoryConfigStorage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String mpToken <span class="token operator">=</span> tokenClient<span class="token punctuation">.</span><span class="token function">getMpToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        configStorage<span class="token punctuation">.</span><span class="token function">setAccessToken</span><span class="token punctuation">(</span>mpToken<span class="token punctuation">)</span><span class="token punctuation">;</span>        configStorage<span class="token punctuation">.</span><span class="token function">setExpiresTime</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span> <span class="token number">100000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        WxMpService service <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyWxMpServiceImpl</span><span class="token punctuation">(</span>tokenClient<span class="token punctuation">)</span><span class="token punctuation">;</span>        service<span class="token punctuation">.</span><span class="token function">setWxMpConfigStorage</span><span class="token punctuation">(</span>configStorage<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> service<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swagger+yapi使用笔记</title>
      <link href="/53387.html"/>
      <url>/53387.html</url>
      
        <content type="html"><![CDATA[<p>写接口文档对于RD来说是件非常烦心的事情，而且随着需求迭代，人员流动，接口文档的编写一般面临以下问题：</p><ul><li>没有及时编写</li><li>没有及时更新</li><li>文档零散错落在不同的页面</li><li>因编写人的行为习惯而又显著的差异</li><li>因人员流动，交接时不太方便，在wiki中的文档或者word文档比较难自动mock<a id="more"></a></li></ul><h1 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h1><p>swagger是一个流行的API开发框架，这个框架以“开放API声明”（OpenAPI Specification，OAS）为基础，<br>对整个API的开发周期都提供了相应的解决方案，是一个非常庞大的项目（包括设计、编码和测试，几乎支持所有语言）。</p><h2 id="springfox"><a href="#springfox" class="headerlink" title="springfox"></a>springfox</h2><p>springfox的大致原理就是，在项目启动的过种中，spring上下文在初始化的过程，<br>框架自动跟据配置加载一些swagger相关的bean到当前的上下文中，并自动扫描系统中可能需要生成api文档那些类，<br>并生成相应的信息缓存起来。如果项目MVC控制层用的是springMvc那么会自动扫描所有Controller类，并生成对应的文档描述数据.</p><p>该数据是json格式，通过路径：项目地址/ v2/api-docs可以访问到该数据，然后swaggerUI根据这份数据生成相应的文档描述界面。<br>因为我们能拿到这份数据，所以我们也可以生成自己的页面.</p><h2 id="SpringBoot-结合-Swagger2"><a href="#SpringBoot-结合-Swagger2" class="headerlink" title="SpringBoot 结合 Swagger2"></a>SpringBoot 结合 Swagger2</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>springfox-swagger2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.7.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>springfox-swagger-ui<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.7.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>上面两个依赖的作用:</p><p>springfox-swagger2依然是依赖OSA规范文档，也就是一个描述API的json文件，而这个组件的功能就是帮助我们自动生成这个json文件，<br>springfox-swagger-ui就是将这个json文件解析出来，用一种更友好的方式呈现出来。</p><h3 id="配置Swagger2"><a href="#配置Swagger2" class="headerlink" title="配置Swagger2"></a>配置Swagger2</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@EnableSwagger2</span><span class="token comment" spellcheck="true">// 只针对开发环境和测试环境</span><span class="token annotation punctuation">@Profile</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token string">"development"</span><span class="token punctuation">,</span> <span class="token string">"testing"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Swagger2Config</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> Docket <span class="token function">createRestApi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Docket</span><span class="token punctuation">(</span>DocumentationType<span class="token punctuation">.</span>SWAGGER_2<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">apiInfo</span><span class="token punctuation">(</span><span class="token function">apiInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">apis</span><span class="token punctuation">(</span>RequestHandlerSelectors<span class="token punctuation">.</span><span class="token function">basePackage</span><span class="token punctuation">(</span><span class="token string">"com.hetao101.channel.web"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 监听的package名字</span>                <span class="token punctuation">.</span><span class="token function">paths</span><span class="token punctuation">(</span>PathSelectors<span class="token punctuation">.</span><span class="token function">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> ApiInfo <span class="token function">apiInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ApiInfoBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">title</span><span class="token punctuation">(</span><span class="token string">"市场-渠道管理-接口api文档"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 当前项目接口文档的简单描述</span>                <span class="token punctuation">.</span><span class="token function">version</span><span class="token punctuation">(</span><span class="token string">"1.0"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 版本号</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="Swagger常用注解说明"><a href="#Swagger常用注解说明" class="headerlink" title="Swagger常用注解说明"></a>Swagger常用注解说明</h3><p>@Api<br>用在类上，说明该类的作用。</p><pre class=" language-Java"><code class="language-Java">@Api(value = "Message-API", produces = "application/json")</code></pre><p>@Api注解上有一个tags属性，用于进行接口分组分类</p><p>@ApiOperation<br>是上面@Api注解的附属注解，用在方法上,说明方法的作用，每一个url资源的定义。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"消息列表"</span><span class="token punctuation">,</span> notes <span class="token operator">=</span> <span class="token string">"消息列表"</span><span class="token punctuation">)</span></code></pre><p>@ApiModel<br>用在POJO上，用于描述一个Bean的信息，可以用于是请求参数对象类(Application/Json)，也可以用于返回对象类上。<br>@ApiModelProperty<br>是上面的@ApiModel注解的附属注解，用于描述具体的属性。</p><pre class=" language-Java"><code class="language-Java">@ApiModel(value="user对象",description="用户对象user")public class User implements Serializable{    @ApiModelProperty(value="用户名",name="username",example="xingguo",required=true)    private String username;}</code></pre><p>@ApiParam<br>用于请求属性上，一般用于路径参数或者form表单请求</p><pre class=" language-Java"><code class="language-Java">@ApiParam(value = "邮箱或用户名", required = true) @RequestParam("value") String value</code></pre><h1 id="yapi"><a href="#yapi" class="headerlink" title="yapi"></a>yapi</h1><p><img src="http://ody8qw44c.bkt.clouddn.com/2018-09-28-15381050024055.jpg" alt=""><br><a href="https://github.com/YMFE/yapi" target="_blank" rel="noopener">YMFE/yapi: YApi 是一个可本地部署的、打通前后端及QA的、可视化的接口管理平台</a><br>yapi是支持Swagger导入的，上面的教程中，我们在Spring boot项目中引入了swagger-ui jar包，轻而易举生成了Web形式的文档，但是JSON文件怎么生成呢？<br>原来 /v2/api-docs 路径就是json文件的内容，我们可以用wget命令下载json文件,示例如下：</p><pre class=" language-shell"><code class="language-shell">wget -O swagger.json http://127.0.0.1:8001/v2/api-docs</code></pre><p>其中 <code>http://127.0.0.1:8001</code>是我本地项目的访问方式，这样会得到接口的JSON文件–swagger.json。</p><h2 id="swagger文档导入yapi"><a href="#swagger文档导入yapi" class="headerlink" title="swagger文档导入yapi"></a>swagger文档导入yapi</h2><p>有了swagger API文档文件以后就可以导入Yapi了，官方提供了两种方式：</p><h3 id="Web控制台导入"><a href="#Web控制台导入" class="headerlink" title="Web控制台导入"></a>Web控制台导入</h3><p><img src="http://ody8qw44c.bkt.clouddn.com/2018-09-28-15381065558095.jpg" alt=""></p><h3 id="命令行导入"><a href="#命令行导入" class="headerlink" title="命令行导入"></a>命令行导入</h3><p>第一步，安装yapi工具</p><pre class=" language-shell"><code class="language-shell">npm install -g yapi-cli</code></pre><p>第二步，在任意一个目录下新建配置文件 yapi-import.json，内容如下：</p><pre class=" language-JSON"><code class="language-JSON">{  "type": "swagger",  "token": "17fba0027f300248b804",  "file": "swagger.json",  "merge": "normal",  "server": "http://yapi.local.qunar.com:3000"}</code></pre><p>type 是数据数据方式，目前官方只支持 swagger</p><p>token 是项目 token，在 项目设置 -&gt; token 设置获取</p><p>file 是 swagger 接口文档文件，可使用绝对路径或 url</p><p>merge 有三种导入方式(v1.3.23+支持) normal, good, mergin<br>普通模式(normal)：不导入已存在的接口；<br>智能合并(good)：已存在的接口，将合并返回数据的 response，适用于导入了 swagger 数据，保留对数据结构的改动；<br>完全覆盖(mergin)：不保留旧数据，完全使用新数据，适用于接口定义完全交给后端定义， 默认为 normal</p><p>server 是 yapi 服务器地址</p><p>第三步，在新建配置文件的当前目录，执行下面指令</p><pre class=" language-shell"><code class="language-shell">yapi import</code></pre><h1 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h1><p><a href="https://legacy.gitbook.com/book/huangwenchao/swagger/details" target="_blank" rel="noopener">Swagger从入门到精通 · GitBook (Legacy)</a><br><a href="https://blog.csdn.net/itguangit/article/details/78978296" target="_blank" rel="noopener">一篇文章带你搞懂 SpringBoot与Swagger整合 - CSDN博客</a><br><a href="https://yapi.ymfe.org/documents/data.html#swagger-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5" target="_blank" rel="noopener">Yapi-数据导入-教程</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> yapi </tag>
            
            <tag> swagger </tag>
            
            <tag> DONE </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
