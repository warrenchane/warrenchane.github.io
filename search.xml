<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>learning-spider</title>
      <link href="/2020/01/17/learning-spider/"/>
      <url>/2020/01/17/learning-spider/</url>
      
        <content type="html"><![CDATA[<h1 id="需要学习的库"><a href="#需要学习的库" class="headerlink" title="需要学习的库"></a>需要学习的库</h1><p><a href="https://cn.python-requests.org/zh_CN/latest/" target="_blank" rel="noopener">Requests: 让 HTTP 服务人类 — Requests 2.18.1 文档</a></p><p><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/" target="_blank" rel="noopener">Beautiful Soup Documentation — Beautiful Soup 4.4.0 documentation</a></p><h2 id="练练手"><a href="#练练手" class="headerlink" title="练练手"></a>练练手</h2><p><a href="https://zhuanlan.zhihu.com/p/21320392?refer=passer" target="_blank" rel="noopener">免费实用的API接口 - 知乎</a> </p><h1 id="Requests-学习"><a href="#Requests-学习" class="headerlink" title="Requests 学习"></a>Requests 学习</h1><h2 id="开发哲学"><a href="#开发哲学" class="headerlink" title="开发哲学"></a>开发哲学</h2><blockquote><p>Beautiful is better than ugly.(美丽优于丑陋)<br>Explicit is better than implicit.(直白优于含蓄)<br>Simple is better than complex.(简单优于复杂)<br>Complex is better than complicated.(复杂优于繁琐)<br>Readability counts.(可读性很重要)</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre class=" language-bash"><code class="language-bash">pip <span class="token function">install</span> requests</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> requestsr <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'https://api.github.com/events'</span><span class="token punctuation">)</span>r <span class="token operator">=</span> requests<span class="token punctuation">.</span>post<span class="token punctuation">(</span><span class="token string">'http://httpbin.org/post'</span><span class="token punctuation">,</span> data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'key'</span><span class="token punctuation">:</span><span class="token string">'value'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>r <span class="token operator">=</span> requests<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token string">'http://httpbin.org/put'</span><span class="token punctuation">,</span> data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'key'</span><span class="token punctuation">:</span><span class="token string">'value'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>r <span class="token operator">=</span> requests<span class="token punctuation">.</span>delete<span class="token punctuation">(</span><span class="token string">'http://httpbin.org/delete'</span><span class="token punctuation">)</span>r <span class="token operator">=</span> requests<span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token string">'http://httpbin.org/get'</span><span class="token punctuation">)</span>r <span class="token operator">=</span> requests<span class="token punctuation">.</span>options<span class="token punctuation">(</span><span class="token string">'http://httpbin.org/get'</span><span class="token punctuation">)</span>payload <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'key1'</span><span class="token punctuation">:</span> <span class="token string">'value1'</span><span class="token punctuation">,</span> <span class="token string">'key2'</span><span class="token punctuation">:</span> <span class="token string">'value2'</span><span class="token punctuation">}</span>r <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">"http://httpbin.org/get"</span><span class="token punctuation">,</span> params<span class="token operator">=</span>payload<span class="token punctuation">)</span></code></pre><p>其中 data 属性用于传递body属性，params用于传递url 参数.</p><p>如果想要传递cookies到服务器，可以使用cookies参数</p><p>如果想要传递headers到服务器，可以使用headers参数<br>下图是完整的列表<br><img src="https://blog-1254114069.cos.ap-beijing.myqcloud.com/blog/2020/01/17/15792515222074.jpg" alt=""></p><h3 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h3><p><code>r</code>保存的是一个response对象，对象中的属性如下：</p><table><thead><tr><th>属性名或者方法</th><th>属性含义</th></tr></thead><tbody><tr><td>status_code</td><td>响应状态码</td></tr><tr><td>headers</td><td>响应头</td></tr><tr><td>json()</td><td>返回内容为JSON</td></tr><tr><td>content</td><td>二进制响应内容</td></tr><tr><td>raw</td><td>原始响应内容</td></tr></tbody></table><h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><h3 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h3><p>基本身份认证<br>OAuth 认证<br>OAuth2 认证</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动化测试 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tq-learning</title>
      <link href="/2020/01/16/tq-learning/"/>
      <url>/2020/01/16/tq-learning/</url>
      
        <content type="html"><![CDATA[<h1 id="TqSdk"><a href="#TqSdk" class="headerlink" title="TqSdk"></a>TqSdk</h1><p>官方文档：<a href="https://doc.shinnytech.com/tqsdk/latest/intro.html" target="_blank" rel="noopener">TqSdk 介绍 — TianQin Python SDK 1.5.1 文档</a><br>对照米匡学习：<a href="http://rqalpha.io/zh_CN/latest/intro/overview.html" target="_blank" rel="noopener">介绍 — rqalpha 3.4.x 文档</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre class=" language-bash"><code class="language-bash">pip <span class="token function">install</span> tqsdk</code></pre><h2 id="基础属性"><a href="#基础属性" class="headerlink" title="基础属性"></a>基础属性</h2><h3 id="交易所代码"><a href="#交易所代码" class="headerlink" title="交易所代码"></a>交易所代码</h3><table><thead><tr><th>交易所</th><th>代码</th></tr></thead><tbody><tr><td>XSHE</td><td>深交所</td></tr><tr><td>XSHG</td><td>上交所</td></tr><tr><td>DCE</td><td>大连商品交易所</td></tr><tr><td>SHFE</td><td>上海期货交易所</td></tr><tr><td>CFFEX</td><td>中国金融期货交易所</td></tr><tr><td>CZCE</td><td>郑州商品交易所</td></tr></tbody></table><h3 id="期货合约代码"><a href="#期货合约代码" class="headerlink" title="期货合约代码"></a>期货合约代码</h3><table><thead><tr><th>品种</th><th>品种代码</th><th>示例合约</th></tr></thead><tbody><tr><td>白糖</td><td>SR</td><td>SR005表示白糖2005合约</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> futures </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>王阳明</title>
      <link href="/2020/01/14/wang-yang-ming/"/>
      <url>/2020/01/14/wang-yang-ming/</url>
      
        <content type="html"><![CDATA[<h2 id="心即理"><a href="#心即理" class="headerlink" title="心即理"></a>心即理</h2><p>龙场悟道</p><h2 id="致良知"><a href="#致良知" class="headerlink" title="致良知"></a>致良知</h2><p>江西平叛</p><h2 id="四句教"><a href="#四句教" class="headerlink" title="四句教"></a>四句教</h2><p>南征广西</p><blockquote><p>无善无恶心之体<br>有善有恶意之动<br>知善知恶是良知<br>为善去恶是格物</p></blockquote><h2 id="破山中贼易，破心中贼难"><a href="#破山中贼易，破心中贼难" class="headerlink" title="破山中贼易，破心中贼难"></a>破山中贼易，破心中贼难</h2><p>剿匪之前</p><h2 id="知行合一"><a href="#知行合一" class="headerlink" title="知行合一"></a>知行合一</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 哲学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 王阳明 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用hexo+mweb进行高效写作</title>
      <link href="/2019/09/26/shi-yong-hexo-mweb-jin-xing-gao-xiao-xie-zuo/"/>
      <url>/2019/09/26/shi-yong-hexo-mweb-jin-xing-gao-xiao-xie-zuo/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>上一篇文章中已经介绍如何基于hexo + github-pages搭建自己的博客站点，搭建和部署是及其简单的，困难的是把写作这件事情坚持下来。</p><a id="more"></a><p>MarkDown文档格式对程序员比较友好，对于普通的文字工作者来说就不是那么友好了，所以需要一把利器来帮忙解决markdown编写的问题。</p><h3 id="mweb设置"><a href="#mweb设置" class="headerlink" title="mweb设置"></a>mweb设置</h3><p><a href="https://zh.mweb.im/" target="_blank" rel="noopener">MWeb - 专业的Markdown写作、记笔记、静态博客生成软件 - MWeb</a><br>里面有详细的购买方法（原创不易，支持一下）</p><p>唯一需要配置的就是设置图床<br>添加图床配置，我用的是七牛云<br><img src="http://ody8qw44c.bkt.clouddn.com/2018-09-26-15379637472167.jpg" alt=""><br><img src="https://blog-1254114069.cos.ap-beijing.myqcloud.com/blog/2020/01/14/15789889148863.jpg" alt=""></p><p><img src="http://ody8qw44c.bkt.clouddn.com/15379635104626.jpg" alt=""></p><h3 id="next-主题配置"><a href="#next-主题配置" class="headerlink" title="next 主题配置"></a>next 主题配置</h3><p><a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener">hexo的next主题个性化教程:打造炫酷网站 | Moorez</a></p><p><a href="https://shjhe.github.io/hexo/2018/07/04/Hexo%20Next%E4%B8%BB%E9%A2%98%E5%BC%80%E5%90%AF%E5%AD%97%E6%95%B0%E7%BB%9F%E8%AE%A1%E5%8F%8A%E9%98%85%E8%AF%BB%E6%97%B6%E9%95%BF/" target="_blank" rel="noopener">Hexo Next主题开启字数统计及阅读时长 | Tyler FE</a></p><p><a href="https://blog.runningcoder.me/2018/04/26/create-personal-blog-with-github-and-hexo-V/" target="_blank" rel="noopener">手摸手教你用github和hexo搭建个人博客（五） | Kevin的博客</a></p><h3 id="hexo-theme-matery"><a href="#hexo-theme-matery" class="headerlink" title="hexo-theme-matery"></a>hexo-theme-matery</h3><p><a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/" target="_blank" rel="noopener">Hexo博客主题之hexo-theme-matery的介绍 | 闪烁之狐</a></p><h3 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h3><p>引用相同站点内其他资源时采用站点内地址形式<br>post_link 标签</p><pre class=" language-Hexo"><code class="language-Hexo">{% post_link hello-world %}</code></pre><h3 id="COS-腾讯云存储-与MWeb结合"><a href="#COS-腾讯云存储-与MWeb结合" class="headerlink" title="COS(腾讯云存储)与MWeb结合"></a>COS(腾讯云存储)与MWeb结合</h3><!--[tencentyun/coscmd](https://github.com/tencentyun/coscmd)MWeb支持直接上传文件至腾讯云的服务器，用于替代七牛云正如参考文章中说的，每次在开机的时候需要手动启动一下服务，--><!--coscmd config -a AKIDGK9uQgxSxCD2cyoze3C5i6E5h5GCENaP -s jEUVUFl23oJYYIm35sRmrIUQ6WgbHhrl -b blog-1254114069 -r ap-beijing--><!--```pm2 start --name qcloud-cos-mweb ./run.sh```--><p>直接使用图床服务<br><img src="https://blog-1254114069.cos.ap-beijing.myqcloud.com/blog/2020/01/14/15789963119518.jpg" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6-export-and-import</title>
      <link href="/2018/10/21/es6-export-and-import/"/>
      <url>/2018/10/21/es6-export-and-import/</url>
      
        <content type="html"><![CDATA[<p>在ES5中，如果js文件依赖于其他js文件，那么必须在html中先加载这些依赖，也就是要控制好每一个js文件的加载顺序。<br>ES6中引入了export和import概念，将一个程序拆分成互相依赖的小文件，再用简单的方拼装起来。</p><h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><p>官方解释：</p><blockquote><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。</p></blockquote><p>理解：一个模块可以理解为一个类，引用这个类的文件无法获取类里面的所有变量(类似于类属性设置为private)，想要让引用它的文件，可以访问内部变量必须用export关键字输出(类似于属性设置为public)，总之一句话，要使用引用文件内部的变量只能使用export关键字输出。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//输出变量用法1</span><span class="token keyword">export</span> <span class="token keyword">var</span> firstName <span class="token operator">=</span> <span class="token string">'Michael'</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">var</span> lastName <span class="token operator">=</span> <span class="token string">'Jackson'</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">var</span> year <span class="token operator">=</span> <span class="token number">1958</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出变量用法2</span><span class="token keyword">var</span> firstName <span class="token operator">=</span> <span class="token string">'Michael'</span><span class="token punctuation">;</span><span class="token keyword">var</span> lastName <span class="token operator">=</span> <span class="token string">'Jackson'</span><span class="token punctuation">;</span><span class="token keyword">var</span> year <span class="token operator">=</span> <span class="token number">1958</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token punctuation">{</span>firstName<span class="token punctuation">,</span> lastName<span class="token punctuation">,</span> year<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出函数用法1</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">multiply</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> x <span class="token operator">*</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出函数用法2</span><span class="token keyword">function</span> <span class="token function">v1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">v2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token keyword">export</span> <span class="token punctuation">{</span>  v1 <span class="token keyword">as</span> streamV1<span class="token punctuation">,</span>  v2 <span class="token keyword">as</span> streamV2<span class="token punctuation">,</span>  v2 <span class="token keyword">as</span> streamLatestVersion<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出类</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span></code></pre><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块。</p><p>示例：</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// main.js</span><span class="token keyword">import</span> <span class="token punctuation">{</span>firstName<span class="token punctuation">,</span> lastName<span class="token punctuation">,</span> year<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./profile'</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">setName</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span> <span class="token punctuation">{</span>  element<span class="token punctuation">.</span>textContent <span class="token operator">=</span> firstName <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> lastName<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 说明：上面的代码中，import命令加载profile.js文件，并从中输入变量，import命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。</span><span class="token comment" spellcheck="true">// 注意，这里import命令中的内容，需要是export命令输出的内容。</span></code></pre><h3 id="export-default"><a href="#export-default" class="headerlink" title="export default"></a>export default</h3><p>从前面的例子可以看出，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。</p><p>为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。</p><p>举例说明之：</p><pre><code>// export-default.jsexport default function () {  console.log('foo');}// import-default.jsimport customName from './export-default';customName(); // 'foo'</code></pre><p>上面代码是一个模块文件 export-default.js，它的默认输出是一个函数，其他模块加载该模块的时候，import命令可以为该匿名函数指定任意名字。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>企业财务报表分析-张新民</title>
      <link href="/2018/10/18/qi-ye-cai-wu-bao-biao-fen-xi-zhang-xin-min/"/>
      <url>/2018/10/18/qi-ye-cai-wu-bao-biao-fen-xi-zhang-xin-min/</url>
      
        <content type="html"><![CDATA[<h1 id="财务报表"><a href="#财务报表" class="headerlink" title="财务报表"></a>财务报表</h1><h2 id="资产负债表"><a href="#资产负债表" class="headerlink" title="资产负债表"></a>资产负债表</h2><p>资产=负债+股东权益<br>右边归结起来一句话：资源的权益归属。</p><a id="more"></a><h3 id="资产分类"><a href="#资产分类" class="headerlink" title="资产分类"></a>资产分类</h3><p>按照流动性分可以分为流动资产与非流动资产<br>流动资产：一年内（也可以说是一个经营周期，因为房地产等特殊行业一个经营周期一般为3年以上）可变现为货币的资产<br>主要包括：</p><ul><li>货币</li><li>债权</li><li>存货</li></ul><p>债权包括：所有的应收和预付都归结到债权资产类。</p><p>相应的是非流动资产（长期利用的资产），包括：</p><ul><li>长期投资类</li><li>固定资产类</li><li>无形资产类</li></ul><p>长期投资类包括：可供出售金融资产、持有至到期投资（长期债权投资）、长期股权投资（这是分析的重点）。</p><p>按照资产对利润的共享方式可以分为经营资产和投资资产。<br>经营资产包括：</p><ul><li>货币</li><li>债权</li><li>存货</li><li>固定资产</li><li>无形资产</li></ul><p>投资资产包括：</p><ul><li>可供出售金融资产</li><li>持有至到期投资</li><li>长期股权投资</li><li>交易性金融资产</li></ul><p>这种资产划分的方式更有意义，不是资产的流动和非流动解决利润的转化问题，而是经营和投资与流动和非流动的结合解决了我们的分析问题。<br>有些企业只有经营没有投资，有些企业只有投资很少有经营，有些企业是经营和投资并重。</p><h3 id="资源的权益归属"><a href="#资源的权益归属" class="headerlink" title="资源的权益归属"></a>资源的权益归属</h3><p>包括：</p><ul><li>债权人——负债</li><li>股东（所有者）——股东所有者权益</li></ul><p>资产形态的变化不影响负债和股东权益价值量的变化。比如说：借款1亿，这个时候负债就是1亿，在经营过程中花掉了5000万转化为固定资产，这个时候资产变为5000万固定资产和5000万货币。</p><p>负债按照偿还期的长短也分为流动负债和非流动负债。</p><p>股东权益构成：</p><ul><li>实收资本（股本）</li><li>资本公积</li><li>盈余公积</li><li>未分配利润</li></ul><h2 id="利润表"><a href="#利润表" class="headerlink" title="利润表"></a>利润表</h2><p>收入-费用 = 净利润<br>收入：凡是使利润增加的因素都是收入。<br>费用：凡是使利润减少的因素都是费用。</p><h2 id="现金流量表"><a href="#现金流量表" class="headerlink" title="现金流量表"></a>现金流量表</h2><p>反映企业一定时间现金及现金等价物（货币资金）收支情况的报表。<br>现金流入量-现金流出量=现金流净额<br>经营活动、投资活动和筹资活动。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>资产负债表</p><table><thead><tr><th>表</th><th align="left">说明什么问题</th><th align="left">概况</th><th align="left">另外一种角度</th></tr></thead><tbody><tr><td>资产负债表</td><td align="left">资源结构以及权益归属</td><td align="left">实力（财力）</td><td align="left">底子</td></tr><tr><td>利润表</td><td align="left">一定时期的权益</td><td align="left">能力</td><td align="left">面子</td></tr><tr><td>现金流量表</td><td align="left">强调钱怎么来，怎么花</td><td align="left">活力</td><td align="left">日子</td></tr></tbody></table><p>造假最容易的是在面子，就像是人的化妆一样，面子最容易伪造。造假最重要的一个特征就是反常识。</p><h1 id="企业设立、经营与财务报表"><a href="#企业设立、经营与财务报表" class="headerlink" title="企业设立、经营与财务报表"></a>企业设立、经营与财务报表</h1><p>资产负债表表是一个综合反映，利润表是一段时期的效益表现，现金流量表是收支变化情况。<br>一般而言，现金流量表是对资产负债表中第一行货币一段时间内的展开说明。<br>利润表和现金流量表是对资产负债表中某一项或者某几项的补充说明。</p><p>盈余公积和未分配利润是净利润的分配结果。</p><p>存货：用于销售的产品。</p><p>对外交易会产生收入，得到的是货币或者是债权。</p><p>股东入资的三重效应：</p><ul><li>为经营奠定基础</li><li>对潜在的债务提供保证</li><li>确立股东之间的利益关系</li></ul><h1 id="企业发展、扩张与财务报表"><a href="#企业发展、扩张与财务报表" class="headerlink" title="企业发展、扩张与财务报表"></a>企业发展、扩张与财务报表</h1><p>前面已经说过，资产按照对利润的共享可以分为经营资产与投资资产。</p><h2 id="企业发展与扩张的两个途径："><a href="#企业发展与扩张的两个途径：" class="headerlink" title="企业发展与扩张的两个途径："></a>企业发展与扩张的两个途径：</h2><ul><li>自主经营</li><li>对外控制性投资</li></ul><h2 id="扩张的资金来源"><a href="#扩张的资金来源" class="headerlink" title="扩张的资金来源"></a>扩张的资金来源</h2><p>有两个渠道：</p><ul><li>筹资：股东给，银行借</li><li>经营利润积累</li></ul><p>股东不可能天天给，企业开始的时候股东才会给，当然上市公司可以增发股份，股东给了钱以后可以通过经营活动赚取利润。<br>银行借款是企业经常性的扩张现金来源。</p><h3 id="扩张的资金投向"><a href="#扩张的资金投向" class="headerlink" title="扩张的资金投向"></a>扩张的资金投向</h3><ul><li>无形资产</li><li>固定资产</li><li>在建工程</li></ul><p>重大的扩张一般都不是先形成固定资产，先形成在建工程，在建工程一般时间跨度大，最终形成固定资产，也有可能是坏掉的在建工程。<br>在建工程是没有支持近期的经营活动的，没有经营行为。</p><p>一个现象：很多时候现金流量表的自由现金流(经营现金流量净额+投资现金流量净额)&lt;0，说明有资金缺口，这里面的原因往往和在建工程相关。这种情况不需要过分担心，关键在于投资效益几何。投资现金流量净额小于零说明企业在扩张。</p><p>如果在建工程时间过程会产生两个后果：</p><ul><li>单位产能成本过高（周期过长，利息因素会过高）；</li><li>行业产能过剩，建造时信心满满，建造完成时却生产过剩，这个时候是重大的投资失误。</li></ul><h2 id="控制性投资对企业的影响"><a href="#控制性投资对企业的影响" class="headerlink" title="控制性投资对企业的影响"></a>控制性投资对企业的影响</h2><h3 id="控制性投资的撬动效应"><a href="#控制性投资的撬动效应" class="headerlink" title="控制性投资的撬动效应"></a>控制性投资的撬动效应</h3><p>控制性投资是企业在不对外融资的前提下，实现跨越式发展的重要方式。</p><p><strong>货币资金存量根本就不是完全可自由动用的货币资金。</strong></p><p>前面说扩张有两种：自主经营和控制性投资<br>自主经营的好处是自己做自己赚，所有的利润都是自己的，但是同时所有的风险都是自己承担。<br>有时为了规避风险，通过对外控制性投资，成立控股子公司，引入第三方资金一起做新的产品线，达到扩张的目的。<br>对外控制性投资投入的资金在母公司资产负债报表上表现为<code>长期股权投资</code>。<br>由于是子公司是控股公司，所以会归入合并报表。<br>子公司的资产负债表、利润表、现金流量表会归入企业合并报表。</p><h3 id="控制性投资的识别问题"><a href="#控制性投资的识别问题" class="headerlink" title="控制性投资的识别问题"></a>控制性投资的识别问题</h3><p>可能包含控制性股权投资的项目：</p><ul><li>长期股权投资</li></ul><p>长期股权投资并不都是控制性投资并不都是控制性投资，如何识别控制性股权投资的规模？<br>控制性股权投资的规模 = 母公司的长期股权投资 - 合并资产的长期股权投资 + 母公司其他应收款 - 合并报表其他应收款<br>前者是入资，后者是筹资。</p><p>长期股权投资<br>通过控制性股权投资注资以后，子公司需要额外的资金怎么办，这个时候子公司需要借钱，一般而言对于集团而言都不是分散筹资的，而是集团统一借钱，然后再给子公司按需分配下去，这样会整个集中一个集团融资的一种能力和潜力，能够获得一个比较好的贷款条件。<br>贷款1亿和贷款100亿对于银行来说是不一样的，银行更愿意给大集团贷款以规避风险。</p><p>拿到控制性投资的总额以后，可以算出一个控制性投资总额占资产总额的一个比例，看出公司是否是对外投资为主导。</p><h3 id="撬动效应"><a href="#撬动效应" class="headerlink" title="撬动效应"></a>撬动效应</h3><p>$$  撬动效应 = \dfrac{合并报表资产总额 - 母公司资产总额}{控制性股权投资总额} $$</p><p>子公司也是公司，母公司可以做的时候，子公司全部可以做，比如说：筹资，经营利润</p><p>撬动效应可以看到子公司的经营情况。</p><h3 id="控制性投资效益表现形式"><a href="#控制性投资效益表现形式" class="headerlink" title="控制性投资效益表现形式"></a>控制性投资效益表现形式</h3><p>控制性投资是被控制公司的经营资产。<br>子公司的基本效益表现在子公司的核心利润里面。</p><p>子公司分红表现为母公司的投资收益。</p><h1 id="从财务报表看战略"><a href="#从财务报表看战略" class="headerlink" title="从财务报表看战略"></a>从财务报表看战略</h1><p>战略对于一家企业来说非常重要，没有企业没有战略，但是没有企业天天讲战略，战略是融入到企业骨髓中去的。</p><p>创业最重要的三件事情：<code>找人、找钱和定战略</code><br>战略的实施需要有资源的支持，只要是资源的动用就一定会在报表中留下痕迹。<br>当股东在设立的时候想的问题就是战略问题。<br>企业家见面不会交流战略问题，一般聊的是两个问题：资金（财务管理）问题与营销（市场）问题。</p><h2 id="战略实施的资源基础"><a href="#战略实施的资源基础" class="headerlink" title="战略实施的资源基础"></a>战略实施的资源基础</h2><p>静态问题与动态问题<br>静态：强调现有的资源结构的战略含义，资产负债表中资源的结构和规模。<br>动态：一段时期内资源流出量的一种关系。</p><p>现金流量表中的投资活动流出量中有两项：购建固定资产（经营相关），投资支付现金（投资相关）。<br>这两项可以看出企业是更强调于自主经营还是对外投资扩张。<br>企业不和外界发生资源交互是不可能的。<br>企业的成功光有自身的努力是不够的。应该站在更大的环境中看企业的发展，因为大环境可能会变，所以企业的战略也会调整，动态的调整在报表中会有痕迹。</p><h2 id="行业的选择与定位"><a href="#行业的选择与定位" class="headerlink" title="行业的选择与定位"></a>行业的选择与定位</h2><ul><li><p>行业选择决定了基本的资产结构。<br>最明显的是固定资产与存货之间的关系。</p></li><li><p>定位：资源、产品定位与市场占有率。<br>我们看一个企业不应该仅仅看资源结构与资源能力，也要看利润效益。<br>定位既包含资源规模问题，又包含产品形象问题。<br>市场占有率往往看产品销量和营业额。</p></li><li><p>扩张战略及其效应<br>对内扩大经营及效应，增加产能<br>对外控制性投资及（撬动效应以外的）效应：资产盘活效应，风险分散效应。<br>控制性股权投资有两个作用：撬动效应和分散风险。<br>案例分析：小型企业低价转让股份给上市公司。</p></li></ul><h2 id="财务分析视角看战略"><a href="#财务分析视角看战略" class="headerlink" title="财务分析视角看战略"></a>财务分析视角看战略</h2><p>全体股东的视角：</p><ul><li>企业资源的一种系统性优化</li><li>它的变化的盈利导向</li></ul><p>所谓系统性优化就不是某类或者某项资产的局部最优，而是强调特定资产在整体中对盈利的贡献。<br>如果年末余年初相比变化很明确，那一定要考虑是否对盈利有贡献。</p><p>控制性股东（或者说大股东）视角<br>如果控股股东（或者说大股东）与全体股东的立场不一致，则控股股东的战略实施就会导致本公司不良资产的形成。<br>如果企业家上市之前干什么什么就成，但是上市以后干什么什么都有问题的时候，可能就是这种情况，控股股东的利益与全体股东利益有冲突。</p><h1 id="从报表看企业竞争力"><a href="#从报表看企业竞争力" class="headerlink" title="从报表看企业竞争力"></a>从报表看企业竞争力</h1><p>竞争力是一种比较优势，一定是和同行业的相比的竞争力</p><h2 id="企业竞争力的财务报表表现"><a href="#企业竞争力的财务报表表现" class="headerlink" title="企业竞争力的财务报表表现"></a>企业竞争力的财务报表表现</h2><p>流动比率与速动比率其实没有什么用。<br>$$  流动比率 = \dfrac{流动资产}{流动负债} $$</p><p>为什么有货币资金还有短期借款，这个是短期借款的安排问题。子公司的贷款都是通过集团来向银行贷款的，以其他应收款（母公司给子公司提供资金的通道）的形式出借给子公司。其他应收款是集团资金管理的安排问题。</p><p>流动资产的核心部分：货币、预付款项、应收票据、应收账款、存货<br>流动负债的核心部分：短期借款、应付票据、应付账款、预收款项</p><h2 id="上下游关系管理"><a href="#上下游关系管理" class="headerlink" title="上下游关系管理"></a>上下游关系管理</h2><h3 id="收款（对下游）过程管理"><a href="#收款（对下游）过程管理" class="headerlink" title="收款（对下游）过程管理"></a>收款（对下游）过程管理</h3><p>$$  应收账款周转率 = \dfrac{营业收入}{平均应收账款} $$<br>==这个指标也是没有多大用处的==<br>企业的债权回收是应收票据、应收账款与预收款项共同推动了一个企业的营业收入额。上面的公式只用了应收账款一项内容，显然是不对的。</p><p>应收账款我们要看的是回款状况，周转速率不是很重要，回款状况和企业的营销策略以及市场竞争地位密切相关。<br>收款状况我们看三个指标：应收票据、应收账款与预收款项。<br>应收票据+应收账款 作为整体看年初与年末的关系<br>看规模，看年末的数据与年初的数据相比。<br>看结构，应收票据是优于应收账款的。</p><p>同理再看预收款项。<br>$$  对下游 = (年末预收 - 年初预收) -（年末应收 - 年初应收） $$<br>这个值越大则对下游的控制力越强<br>得到数据之后与今年的营业额对比来看，看今年的回款情况。</p><h3 id="付款（对上游）过程管理"><a href="#付款（对上游）过程管理" class="headerlink" title="付款（对上游）过程管理"></a>付款（对上游）过程管理</h3><p>看四个指标：应付票据、应付账款、预付款项和存货。<br>$$ 对上游 = 应付-预付-存货 $$</p><p>上下游关系管理一定会反映在经营现金流量上面。<br>应收票据与应收账款的结构是一种竞争优势的体现，吃上游（供应商）的能力是一种竞争优势，吃下游（经销商）的能力是一种竞争优势。</p><h2 id="毛利、毛利率与竞争力"><a href="#毛利、毛利率与竞争力" class="headerlink" title="毛利、毛利率与竞争力"></a>毛利、毛利率与竞争力</h2><p>基本的盈利能力看毛利与毛利率<br>$$ 毛利 = 营业收入 - 营业成本 $$<br>$$ 毛利率= \dfrac{营业收入 - 营业成本}{营业收入}$$</p><h2 id="核心利润、核心利润率与竞争力"><a href="#核心利润、核心利润率与竞争力" class="headerlink" title="核心利润、核心利润率与竞争力"></a>核心利润、核心利润率与竞争力</h2><p>$$ 核心利润 = 毛利 - 营业税金及附加 - 销售费用 - 管理费用 - 财务费用 $$<br>$$ 核心利润率 = \dfrac{毛利 - 营业税金及附加 - 销售费用 - 管理费用 - 财务费用}{营业收入}  $$</p><p>核心利润表明企业经营资产的盈利能力。</p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>企业的竞争力与风险绝不在于流动资产与流动负债的比例。<br>==强调一下：如果一家企业低流动资产对较高流动负债存在并且<code>长期存在</code>，它表明这家企业有一种竞争优势，结合上下游关系管理来分析==</p><h2 id="ROA与ROE"><a href="#ROA与ROE" class="headerlink" title="ROA与ROE"></a>ROA与ROE</h2><p>总资产收益率与净资产收益率<br>一个企业的利润是0并不代表企业没有价值。</p><p>竞争力的财务表现是持续的盈利表现。</p><h1 id="从报表看企业效益和质量"><a href="#从报表看企业效益和质量" class="headerlink" title="从报表看企业效益和质量"></a>从报表看企业效益和质量</h1><p>收入 - 费用 = 净利润<br>使利润增加的因素或者项目叫做收入<br>使利润减少的因素或者项目叫做费用<br>一般谈企业的效益的时候都是说净利润，但是仅仅看净利润是不够的，我们必须要关注利润的结构问题。</p><h2 id="几个重要的指标"><a href="#几个重要的指标" class="headerlink" title="几个重要的指标"></a>几个重要的指标</h2><h3 id="毛利"><a href="#毛利" class="headerlink" title="毛利"></a>毛利</h3><p>$$ 毛利 = 营业收入 - 营业成本 $$<br>意味着企业最基本的产品的最初盈利能力</p><h3 id="核心利润"><a href="#核心利润" class="headerlink" title="核心利润"></a>核心利润</h3><p>$$ 核心利润 = 毛利 - 营业税金及附加 - 销售费用 - 管理费用 - 财务费用 $$<br>核心利润表明经营资产的盈利能力。<br>财务费用与筹资有关，有的算法中是没有将财务费用放置到核心利润里面的，但是筹资往往与经营相关。</p><h3 id="营业利润"><a href="#营业利润" class="headerlink" title="营业利润"></a>营业利润</h3><p>$$ 营业利润 = 核心利润 + 投资收益 + 公允价值变化 - 资产减值损失<br>=  毛利 - 营业税金及附加 - 销售费用 - 管理费用 - 财务费用  + 投资收益 + 公允价值变化 - 资产减值损失 $$<br>专注于主营活动的或者核心业务的企业来讲公允价值变动收益一般不会很大，资产减值损失一般也不会很大<br>所以营业利润的两大重要支柱就是核心利润和投资收益。</p><h3 id="利润总额"><a href="#利润总额" class="headerlink" title="利润总额"></a>利润总额</h3><p>$$ 利润总额 = 营业利润 + 营业外利润 =  营业利润 + 营业外收入 - 营业外支出 $$<br>营业外收入一般为政府补贴收入</p><h3 id="净利润"><a href="#净利润" class="headerlink" title="净利润"></a>净利润</h3><p>净利润就是利润总额减去所得税费用<br>如果企业有控制性投资，企业就需要编制两张利润表，一张是本公司（母公司）利润表，一张是包括子公司的合并利润表。</p><p>合并报表中有一个归属于母公司所有者的净利润，如果公司对子公司不是完全控股的话，归属于母公司所有者的净利润就是母公司控股部分的净利润，剩余部分是少数股东损益。<br>母公司报表的净利润是母公司分红的基础，如果企业要分红，用的是母公司报表的净利润为基础进行分红。<br>合并报表的净利润是评估一个集团的盈利能力指标。<br>归属于母公司所有者的净利润只是一种观念上的表达。</p><h2 id="利润的结构与利润的质量"><a href="#利润的结构与利润的质量" class="headerlink" title="利润的结构与利润的质量"></a>利润的结构与利润的质量</h2><h3 id="营业收入的规模与结构变化"><a href="#营业收入的规模与结构变化" class="headerlink" title="营业收入的规模与结构变化"></a>营业收入的规模与结构变化</h3><p>看规模的时候要看年度间，谈企业的成长性的时候我们一般会看营业额的增长情况。<br>看结构的时候，更多的时候要强调结构变化与持续盈利能力之间的关系问题。<br>比如说有的企业的产品受国家宏观政策的影响比较大，如果没有替代能力的话，原有的结构可能不会有持续盈利的能力。<br>再者看结构的变化与企业竞争优势之间的关系？<br>生产的产品毛利率很高，并且保持一种比较强的市场份额，那么这种结构就是好的结构。市场要认可你的产品才行。</p><h3 id="毛利率的变化"><a href="#毛利率的变化" class="headerlink" title="毛利率的变化"></a>毛利率的变化</h3><p>谈毛利率强调两个问题：</p><ul><li>毛利率体现一种竞争力</li><li>但是存货积压能导致当期毛利率的提高</li></ul><p>存货积压并不完全是因为管理失当造成的积压，存货积压有两种类型：</p><ul><li>管理失当——实物积压</li><li>利润操纵——账面积压</li></ul><p>积压是指超过正常需求的储备，实物积压意味着产大于销，这时单位产品分摊的成本就比较低，积压的存货会分摊固定的成本，所以这时销售成本就会降低，这时毛利率就会提高。<br>账面积压，有些存货已经被卖掉了，但是没有从报表中剔除。<br>从根本上来看存货积压绝不是一个好现象，往往会为未来的亏损奠定基础。</p><h3 id="费用额与费用率的变化"><a href="#费用额与费用率的变化" class="headerlink" title="费用额与费用率的变化"></a>费用额与费用率的变化</h3><p>企业相当多的费用在年度间的稳定性是非常强的，其变化往往伴随着业务的变化。</p><h3 id="资产减值损失"><a href="#资产减值损失" class="headerlink" title="资产减值损失"></a>资产减值损失</h3><p>一个主业突出的企业，其资产减值损失不会太高，资产减值损失意味着相应资产的管理质量。<br>存货减值意味着存货管理有问题，债权有减值意味着债权的管理有问题，固定资产减值意味着固定资产管理有问题。</p><h3 id="投资收益"><a href="#投资收益" class="headerlink" title="投资收益"></a>投资收益</h3><p>如果有控制性投资的话，投资收益的规模取决于子公司的分红情况。</p><h3 id="营业外收入"><a href="#营业外收入" class="headerlink" title="营业外收入"></a>营业外收入</h3><p>营业外收入持续性比较强的话，则说明其中有其内在的东西。<br>一般而言与政府补贴相关。<br>如果是小打小闹的营业外收入的话，通过变卖资产，那这种对利润的贡献是不能持久的。<br>注意：如果持续性比较强的营业外收入是由于政策的问题，那么需要关注这种政策的持久性问题。</p><h2 id="核心利润的现金能力与利润质量"><a href="#核心利润的现金能力与利润质量" class="headerlink" title="核心利润的现金能力与利润质量"></a>核心利润的现金能力与利润质量</h2><p>经营活动产生的现金流量净额规模所包含的核心利润质量信息。</p><p>核心利润 * (1.2 ~ 1.5) 应该等于经营现金流量净额，前提是企业的存货周转次数应该超过2次。周转次数太慢的话，这个关系是不成立的。<br>存货周转次数 = 销货成本 / 平均存货（存货周转次数=销售成本/存货平均余额）。<br>貌似这个对于影视行业不太适用，存货周转次数太小。<br>销货成本也就是营业成本。<br>良性发展的企业肯定是有利润更有经营现金流量。</p><h1 id="从报表看风险"><a href="#从报表看风险" class="headerlink" title="从报表看风险"></a>从报表看风险</h1><h2 id="经营风险"><a href="#经营风险" class="headerlink" title="经营风险"></a>经营风险</h2><p>公司的资产有经营资产与投资资产，经营资产会产生核心利润，控制性资产投资是被控制公司的经营资产，子公司的经营产生子公司的核心利润。</p><p>与未来盈利能力不确定性相关的各种因素，各种比率：</p><ul><li>流动资产与流动负债，更多地强调短期经营与周转关系，没有一个定量的比例，流动资产与流动负债的背后一定与上下游关系管理相关</li><li>毛利率</li><li>核心利润率</li><li>存货周转率<h2 id="财务风险"><a href="#财务风险" class="headerlink" title="财务风险"></a>财务风险</h2>实际上就是贷款融资的风险<br>关心资产负债率，一般来说资产负债率超过70%，企业的财务风险就比较大了，当然特定行业有行业的特性。<br>为啥是70%，因为超过70%，董事会的决议就没有足够的权利，需要开临时股东大会，这时会影响管理层的决策影响力。</li></ul><p>偿贷能力和现金流量相关<br>核心利润率与融资之间也有关系，经营风险与财务风险是密切相关的，经营风险越低，财务风险不可能很高，一般来说是马太效应，经营越好的公司，贷款越容易，贷款的利率也会越低，掌握话语权。</p><p>贷款看三品：人品，产品，押品。<br>人品是管理层，产品看盈利能力，押品是保障措施问题<br>财务风险，不能简单看企业的资产负债率问题。<br>流动负债里面也要看结构。在预收款比较高的企业负债率是被虚夸了的，其实预收虽然在负债中，但是是一种竞争优势的体现，想象一下，货还没有给别人，钱已经收上来了，说明产品很抢手。</p><h2 id="股权结构、公司治理与核心人物变更风险"><a href="#股权结构、公司治理与核心人物变更风险" class="headerlink" title="股权结构、公司治理与核心人物变更风险"></a>股权结构、公司治理与核心人物变更风险</h2><ul><li><p>股权结构的集中、分散与风险<br>股权集中度越高，越能体现第一大股东的权利与意志。</p></li><li><p>还要注意股东大会、董事会以及管理层之间的关系与风险<br>股东是所有权，管理层是经营权。<br>核心管理层一般来讲不会超过10人。<br>董事会成员一般是5~19人之间，一般为单数，便于投票。</p><h2 id="惯性依赖风险"><a href="#惯性依赖风险" class="headerlink" title="惯性依赖风险"></a>惯性依赖风险</h2><p>技术挂帅<br>营销挂帅<br>什么样的战略就会配置什么样的资源，产品的市场定位，一般发生变更会是一个潜在的风险。风险一般会体现在上下游关系管理中，一定是供应商与经销商比利润更敏感。</p><h2 id="竞争环境变化风险"><a href="#竞争环境变化风险" class="headerlink" title="竞争环境变化风险"></a>竞争环境变化风险</h2><p>竞争地位的变化，处于不同地位的企业话语权是不一定的，有的企业总是领袖，如果竞争地位出现变化，那企业的行为跟它的竞争对手之间的关系一定会发生变化。<br>营业外收入依赖的是政策的持续性，如果政策发生变化，那么依赖这项政策的营业外收入的就不可持续了。<br>特定地区的行政领导人变更也会产生潜在的风险。</p><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>能够计算出来的风险是经营风险与财务风险<br>计算不出来的风险是公司治理，股权结构，核心人员变更，竞争环境变化的风险<br>企业的真正风险是那些不能直接计算出来的因素</p></li></ul><h1 id="从报表看前景"><a href="#从报表看前景" class="headerlink" title="从报表看前景"></a>从报表看前景</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 投资 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>韭菜的自我修养-读书笔记</title>
      <link href="/2018/10/18/jiu-cai-de-zi-wo-xiu-yang-du-shu-bi-ji/"/>
      <url>/2018/10/18/jiu-cai-de-zi-wo-xiu-yang-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<p><a href="https://book.douban.com/subject/30314653/" target="_blank" rel="noopener">韭菜的自我修养 (豆瓣)</a><br><img src="https://blog-1254114069.cos.ap-beijing.myqcloud.com/blog/2020/01/14/15789914340532.jpg" alt=""></p><ul><li><p>韭菜是什么？<br>所谓“韭菜”，指的是在交易市场中没有赚到钱甚至赔钱的势单力薄的散户。<br>另外一个特征就是，他们严重缺乏基本的阅读能力。他们是那种买一辈子东西都不读产品说明书的人，他们是那种无论拿到什么，都要问别人怎么用的人……</p><a id="more"></a></li><li><p>韭菜之所以是韭菜，绝大多数情况下只不过是来自同一个原因：<br>他们一进场就开始“买买买”！</p></li><li><p>一旦你需要用钱的时候，市场就会大跌！<br>这个看起来没有逻辑支持，但是这个定律有着惊人的魔力。</p></li><li><p>还有钱的话，就慢慢补仓；钱不够的话，就在场外拼命赚钱。</p></li><li><p>思考带来决策，决策带来行动，行动改变命运</p></li><li><p>区分投机者和投资者的一个标准：<br>投机者拒绝学习，投资者善于学习。<br>交易之前，认真研究，深入学习；交易过后，无论输赢，都要总结归纳，修正自己的观念和思考，以便完善下一次的决策，这么做的人，在我眼里都是投资者，哪怕他们是“快进快出”。</p></li><li><p>“韭菜”们最大的共识是什么呢？<br>据我观察，所有的韭菜都认同一个实际上错误的观点：<br>所谓交易，是一种“零和游戏”。</p></li><li><p>你是想要一个正确的解释呢，还是想要一个让自己感觉舒服的解释？<br>正确的解释，会引发你下一步正确的选择和行动。让自己舒服却肯定不正确的解释，除了让你短暂舒服之外，因为它不是正确的，所以必然只能带来各种“出人意料”的副作用……你到底要哪一个解释？<br>正确的解释很简单：<br><font color="red">我们买入的时机错了</font><br>牛市的时候，鸡犬升天，多差的标的，都有可能持续暴涨；熊市的时候，万马齐喑，有时候好的资产反倒是跌得更狠……</p></li><li><p>为什么在股市中或者网络中普遍存在对骂一声“傻X”的现象呢？<br>因为他们认为这是一个“零和游戏”，所以：<br>a. 两个人中必然有一个是傻X；<br>b. 我这么聪明，所以傻X只能是你！</p></li></ul><p>一切的礼貌与修养，本质上都是深入思考的产物，跟说不说脏话没有关系。</p><p>千万不要以为，正在谈论“价值投资”的人，就是以“价值投资”作为行动与判断依据的人。若是常被表现所迷惑，你的交易成绩只能很差很差。</p><p>成功的交易者永远只是极少数，他们所具备的共同特征就是，他们不为表象所动，他们喜欢探究表现之下的实质。</p><ul><li><p>进入交易市场后，一冲进来不管三七二十一就拼命买买买，通常是被套的“韭菜”。</p></li><li><p>绝大多数人之所以正在讨论“价值投资”，是因为他们已然“被套住”了——这才是实质。这也是为什么有那么多人喜欢讨论“价值投资”的根本原因。</p></li><li><p>“研究透价值所在之后决定是否买卖”和“不管三七二十一先下手之后发现不对再去研究价值”有着天壤之别。</p></li><li><p>很有意思的现象：聪明和愚蠢，竟然不是被天生因素所决定，决定它们的竟然只不过是“顺序”……这和下棋一样，先走什么后走什么，最终决定输赢。这个顺序有其他的称呼，比如：“策略”、“算法”……</p></li><li><p>那些盲目相信“价值投资”的人，只能为自己的错误理解、错误决策默默买单。</p></li><li><p>每一套市面上的投资理论都只能解释一小部分的世界。</p></li><li><p>韭菜缺的不是耐心，缺乏的是实力，所以解决办法是提高自己的实力。那么什么是实力：长期稳定的低成本现金流。<br>无论是低息募资或者有场外赚钱的能力，对于大众来说，低成本募资基本上来说是不可能的，所以只能提高自己场外赚钱的能力。</p></li><li><p>仓位控制：永远要保留一定比例或者一定数量的现金，至于比例是多少，数量是多少，没有定量，因人而异，靠自己琢磨。</p></li><li><p>喜欢冒险的最终都是韭菜<br>冒险在都市传说中经常与“勇敢”混为一谈，在交易市场中这种混淆往往是致命的。优秀的、成功的交易者，最终都是风险厌恶者（这点很容易理解，没有人希望自己的钱袋子少钱）<br>能不冒险绝不冒险<br>即便是必须冒险的时候，也要让傻瓜们冒险，自己在一旁通过观察获得经验。也就是“送死”的事情不要身先士卒。</p></li><li><p>use other people’s money!(用别人的钱！)</p></li><li><p>Watch other people taking risks!（盯着别人冒险！）</p></li><li><p>思考正确的结论真的很难，因为有时候“正确的结论”看起来是那么邪恶，即便在最深处闪闪发光。</p></li><li><p>还有另外一些东西，甚至不是“冒险”，就是找死。比如，借钱冲进交易市场，比如，加上杠杆，再比如，在没有专业技能的情况下去玩期货。</p></li><li><p>计算风险成本要考虑很多因素，你的实力最重要，然后才是回报风险比。</p></li><li><p>TODO：<font color="red">止损线如何设置</font>，这个是需要学习的部分</p></li><li><p>越是短期的预测，越接近于抛硬币；越是长期的预测，越容易接近真实的逻辑推断……所以，降低交易频次的本质，是拒绝抛硬币，坚持逻辑推断。</p></li><li><p>“韭菜”都是冲动的，冲进交易市场，不阅读，不思考，不学习，他们之所以一冲进来就“买买买”，理由非常简单，“别人已经赚到钱了！”<br>被套之后才开始研究“价值投资”的，都是善良的韭菜，因为他们起码还在“默默地承担自己错误决策所带来的损失”，而后希望通过“学习”改善自己的遭遇。<br>更极端的“韭菜”，其实是更加常见的，一般都是要“维权”的！他们要“讨个说法”，讨一个让自己舒服一点的说法。<br>举个例子，今年小米上市，很多人高位接盘被套，他们都把脏水泼在了雷军的身上，这种人就是不折不扣的韭菜。他们完全没有为自己的决策和行为负责的能力。<br>更狠的韭菜是，他们知道自己“被隔”了，所以决定要坚持到“自己能割别人”，在这个过程中，若是谁竟然戳穿了真相，妨碍了“自己将要割韭菜的机会”，他就跟谁拼命。</p></li><li><p>我要是在那里卖这里买就好了！！！<br>所有的韭菜都有这种幻觉。每天都在盯着K线图，不断地在YY：<br>“唉，我要是在那里卖出（瞅着某个价格高点），然后在这里买入（目光挪到某个价格低点）……就好了”<br>“……就好了”，这个是个典型的韭菜句型，人们想要摆脱尴尬的时候所使用的句型。</p></li><li><p>作为交易市场中的一份子，你不大可能在最高点卖出，也很难在最低点买入……最高点和最低点都是因为一小部分交易者的“冲动”造成的</p></li><li><p>回报风险比<br>$$ 回报风险比 = \dfrac{可能的回报}{可能的风险}$$<br>从上面的公式可以看出，想要提高回报风险比，要么提高可能的回报，要么降低可能的风险。<br>减小分母的可行手段：<br>a. 调整止损线，降低自己的风险承担<br>b. 降低每次的交易金额在总资金的占比<br>c. 提高自己场外赚钱的能力（或者募资能力）<br>加大分子的可行手段：<br>a. 选择更为优质的交易标的<br>b. 选择更佳的交易时机<br>c. 放长持有时间</p></li><li><p>学任何东西都是为了“用得上”。<br>学着，但不着急用，等够用了再说……<br>然而，总有一些可以“现学现用”的有效技能。善于学习的人，其实就是善于辨别技能的这方面属性，他们会判断什么东西要慢慢磨练，什么东西要迅速上手，迅速实践。<br>“进场之后，不要动，看上一年之后再动手买。”<br>“只买交易量最大的那么一两个或者两三个标的。”</p></li><li><p>Fear of Missing Out，缩写FOMO，对丧失机会的极度恐惧。<br>越是缺乏机会的人越是容易被这样的句式煽动。</p></li><li><p>孤独是成功交易者最宝贵的品质<br>孤独地交易<br>高手们不重视“正确”，因为谁都可以正确，这并不是什么太难的事情。真正难的事情是，你不仅正确，还与众不同地正确。“特立独行且正确”，才可能产生巨大的交易价值。<br>听大多数人的话，参考少数人的意见，自己做决定。<br>听的意思是听听就够了，毕竟交易的操作是自己来做的，所以交易的决定也一定要自己来做。你必须，也只能为自己的决策负责。<br>独处是促进生产力的最佳方式之一。</p></li><li><p>失败并不可怕，可怕的是面对失败无能为力。</p></li><li><p>控制自己是天下最难的事情，最难过的是想到那些“你自己明明知道应该怎么做却事实上没有那么做”的情节，越是简单的原理越是难以遵守。</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 投资 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《java8实战》笔记</title>
      <link href="/2018/09/30/java8-shi-zhan-bi-ji/"/>
      <url>/2018/09/30/java8-shi-zhan-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h1><h2 id="什么是lambda表达式"><a href="#什么是lambda表达式" class="headerlink" title="什么是lambda表达式"></a>什么是lambda表达式</h2><p>我们可以吧lambda表达式理解为简洁地表示可传递的匿名函数的一种方式：它没有名称，但是有<code>参数列表</code>、<code>函数主体</code>、<code>返回类型</code>，可能还有一个<code>可以抛出的异常列表</code>。</p><a id="more"></a><p>从上面的定义来看，lambda表达式有如下特性：</p><ul><li>匿名——它不像普通的方法那样有一个明确的名称：写得少却想得多。</li><li>函数——lambda函数不像方法那样属于某个特定的类。但是和方法一样，lambda有参数列表、函数主题、返回类型，还有可能会抛出异常。</li><li>传递——lambda表达式可以作为参数传递给方法或者存储变量中。</li><li>简洁——无需像匿名类那样写很多的模板代码。</li></ul><p><code>一定要记住的一点是，lambda表达式是函数，在代码里面如果看到一个变量=lambda表达式，表示的意思是，这个变量是一个函数</code></p><p>来个例子：<br><img src="https://blog-1257857643.cos.ap-beijing.myqcloud.com/blog/15402270083079.jpg" alt=""></p><p>从上图可以看出，lambda表达式有三个部分：</p><ul><li>参数列表</li><li>箭头</li><li>lambda主体</li></ul><h2 id="在哪里使用以及如何使用"><a href="#在哪里使用以及如何使用" class="headerlink" title="在哪里使用以及如何使用"></a>在哪里使用以及如何使用</h2><p>在函数式接口上使用lambda表达式。<br>什么是函数式接口呢？<br>函数式接口就是只定义了一个抽象方法的接口(有多余的继承方法也是不被允许的)。<br>现在的函数式接口都加上了<code>@FunctionalInterface</code>注解，</p><p>用函数式接口可以干什么呢？<br>lambda表达式允许你直接以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例（具体来说，函数式接口一个具体实现的实例）。<br>用匿名内部类也可以完成同样的事情，只不过要分为两步，首先需要提供一个实现，然后再直接内联将它实例化。<br><img src="https://blog-1257857643.cos.ap-beijing.myqcloud.com/blog/15402270964036.jpg" alt=""></p><p>所以，lambda表达式到底是什么呢？lambda表达式也是实例化的对象，不过是是函数式接口的抽象实现并实例化的对象。</p><p>函数描述符<br>函数式接口的抽闲方法的签名基本上就是lambda表达式的签名。我们将这种抽象方法叫做函数描述符。</p><p>如何把lambda付诸实践</p><ul><li>记得行为参数化</li><li>使用函数式接口来传递行为</li><li>执行一个行为</li><li>传递lambda</li></ul><p>装箱：自动将原始类型转换为对应的引用类型的机制。<br>拆箱：将引用类型转换为对应的原始类型。</p><p>使用局部变量<br>lambda表达式允许使用自由变量（不是参数，而是在外层作用域中定义的变量，从这个意义上来说，就是闭包）<br>在使用局部变量的时候有限制，实例变量存储在堆中，而局部变量则保存在栈上。如果lambda可以直接访问局部变量，而且是在同一个线程中使用的，则使用lambda的线程，可能会在分配该变量的线程将这个变量收回之后去访问这个变量，这个时候就产生异常。<br>那么这个限制是什么：局部变量必须显式声明为final。</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>请注意，任何函数式接口都不允许抛出受检异常（Checked Exception）。如果你需要lambda表达式抛出异常，有两种办法：顶一个自己的函数式接口，并声明受检异常，或者把lambda表达式包裹在一个try/catch块中。</p><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p><img src="https://blog-1257857643.cos.ap-beijing.myqcloud.com/blog/15402271196847.jpg" alt=""></p><p>方法引用可以看做仅仅调用特定方法的lambda的一种快捷写法。<br>基本思想：如果一个lambda代表的只是“直接调用这个方法”，那最好还是用名称来调用它，而不是去描述如何调用它。<br>事实上，在我看来方法引用就是实现与调用分离。回想一下前面说的，lambda表达式是函数式接口的实现并实例化，这里面就是两步，第一是实现，第二是实例化。</p><p>如何构建方法引用<br>有三类：</p><ul><li>指向静态方法的方法引用</li><li>指向任意类型实例方法的方法引用</li><li>指向现有对象的实例方法的方法引用</li></ul><h2 id="复合lambda表达的有用方法"><a href="#复合lambda表达的有用方法" class="headerlink" title="复合lambda表达的有用方法"></a>复合lambda表达的有用方法</h2><ul><li>比较器复合<br>对库存进行排序，比较苹果的重量。<br><img src="https://blog-1257857643.cos.ap-beijing.myqcloud.com/blog/15402271468081.jpg" alt=""><br>逆序比较<br><img src="https://blog-1257857643.cos.ap-beijing.myqcloud.com/blog/15402271623499.jpg" alt=""></li></ul><p>比较器链<br><img src="https://blog-1257857643.cos.ap-beijing.myqcloud.com/blog/15402271772457.jpg" alt=""></p><ul><li>谓词复合<br>谓词接口包括三个方法：negate、and和or，咱们可以重用已有的Predicate来创建更加复杂的谓词。<br><img src="https://blog-1257857643.cos.ap-beijing.myqcloud.com/blog/15402271958347.jpg" alt=""></li></ul><ul><li>函数复合<br>Function接口所代表的lambda表达式可以复合起来，Function接口为此配了andThen和compose两个默认的方法。<br>比如f和g都是Function的两个实例<br>f.andThen(g) 表示 先执行f后执行g，数学上的表达式是g(f(x)) 其中x是参数<br>f.compose(g) 表示 先执行g后执行f，数学上的表达式是f(g(x))</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>lambda表达式可以理解为一种匿名函数：没有名称，但是有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常列表</li><li>lambda表达式让你可以简洁地传递代码</li><li>只有在接受函数式接口的地方才可以使用lambda表达式</li><li>lambda表达式允许你直接内联，为函数式接口的抽象方法提供实现，并且将整个表达式作为函数式接口的一个实例。</li><li>Java8 自带一些常用的函数式接口，放在<code>java.util.function</code>包中。</li><li>环绕执行模式（即在方法所必须的代码中间，你需要执行点什么操作，比如资源分配和清理）可以配合lambda提高灵活性和可重用性。</li><li>lambda表达式所需要代表的类型称之为目标类型</li><li>方法引用让你重复使用现有的方法实现并直接传递他们</li><li>Comparator、Predicate和Function等函数式接口都有几个可以用来结合lambda表达式的默认方法。</li></ul><h1 id="函数式数据处理"><a href="#函数式数据处理" class="headerlink" title="函数式数据处理"></a>函数式数据处理</h1><p>集合是 Java 中使用最多的 API。要是没有集合，我们的开发还能做什么呢？几乎每个Java应用程序都会制造和处理集合。</p><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>流是Java8 的新功能特性，它允许你以声明性方式处理数据集合（通过查询语句来表达，而不不是临时编写一个实现）。<br>流还可以透明地并行处理，你无需写任何多线程代码。<br>用一个例子来带入Stream的用法：<br><img src="https://blog-1257857643.cos.ap-beijing.myqcloud.com/blog/15402272177597.jpg" alt=""></p><p><img src="https://blog-1257857643.cos.ap-beijing.myqcloud.com/blog/15402272313419.jpg" alt=""></p><p>后续会说明调用parallelStream方法的时候到底发生了什么？用了多少个线程？对性能有多大的提升？</p><p>从上面的例子可以看到几个好处：</p><ul><li>代码是以声明式方式编写：说明想要完成什么（筛选热量低的菜肴）而不是说明如何实现一个操作（大量的循环和控制语句）。这种方法加上行为参数化可以轻松应对变化的需要。</li><li>可以把几个基础操作链接起来，表达复杂的数据处理流水线（在filter后面接上sorted、map和collect操作），同时保持代码清晰可读。</li></ul><p><img src="https://blog-1257857643.cos.ap-beijing.myqcloud.com/blog/15402272744073.jpg" alt=""></p><p>将流操作链接起来构成流的流水线<br>总结一下，Java8 中的Stream API可以让你写出这样的代码：</p><ul><li>声明性——更简洁，更易读</li><li>可复合——更灵活</li><li>可并行——性能更好</li></ul><h3 id="流简介"><a href="#流简介" class="headerlink" title="流简介"></a>流简介</h3><p>Java 8中的集合支持一个新的Stream方法，它会返回一个流(接口定义在java.util.stream.Stream中)。<br>流到底是什么？简短的定义就是“从支持数据处理操作的源生成的元素序列”。</p><ul><li>元素序列<br>就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序值。<br>因为集合是数据结构，所以它的主要目的是以特定的时间、空间复杂度存储和访问元素。但是流的目的在于表达计算，集合讲的是数据，流讲的是计算。</li><li>源<br>流会使用一个提供数据的源</li><li>数据处理操作<br>流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中常见操作，例如：filter、map、reduce、find、match、sort、group by等。<br>注意：流操作可以顺序执行，也可以并行执行。</li><li>流水线<br>很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线。<br>流水线的操作可以看作对数据源进行数据库式查询。</li><li>内部迭代<br>与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的。</li></ul><p>eg：查找热量最高的三道菜的菜名。<br><img src="https://blog-1257857643.cos.ap-beijing.myqcloud.com/blog/15402272870949.jpg" alt=""></p><p>filter——接受lambda，从流中排除某些元素<br>map——接受一个lambda，将元素转换成其他形式或者提取信息。<br>limit——截断流，使其元素不超过给定数量<br>collect——将流转换为其他形式</p><h3 id="流与集合"><a href="#流与集合" class="headerlink" title="流与集合"></a>流与集合</h3><blockquote><p>粗略来说，集合与流之间的差异就在于什么时候进行计算。集合是一个内存中的数据结构，它包含数据结构中目前所有的值——集合中的每个元素都得先算出来才能添加到集合中。相比之下，流则是在概念上固定的数据结构（你不能添加或者删除元素），其元素是按需计算的。</p></blockquote><ul><li>只能遍历一次<br>和迭代器类似，流只能遍历一次，遍历完以后，流就被消费掉了。如果需要再次使用的话，需要重新遍历流。</li><li>内部迭代与外部迭代<br><img src="https://blog-1257857643.cos.ap-beijing.myqcloud.com/blog/15402273135076.jpg" alt=""></li></ul><h3 id="流操作"><a href="#流操作" class="headerlink" title="流操作"></a>流操作</h3><p>流操作有两类：中间操作与终端操作。<br>中间操作：返回的是流<br>终端操作：从流的流水线中生成结果，其结果不是流。</p><h3 id="流使用"><a href="#流使用" class="headerlink" title="流使用"></a>流使用</h3><p>流的使用包括三件事情：</p><ul><li>一个数据源来执行查询；</li><li>一个中间操作链，形成一条流的流水线；</li><li>一个终端操作，执行流水线，并能生成结果。</li></ul><p>流的流水线类似于构建器模式，在构建器模式中有一个调用链用来设置一套配置，接着是调用built方法。<br><img src="https://blog-1257857643.cos.ap-beijing.myqcloud.com/blog/15402274077891.jpg" alt=""><br><img src="https://blog-1257857643.cos.ap-beijing.myqcloud.com/blog/15402274228294.jpg" alt=""></p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li>流是“从支持数据处理操作的源生成的一系列元素”。</li><li>流利用内部迭代：迭代通过filter、map、sorted等操作被抽象掉了。</li><li>流操作有两类</li><li>中间操作可以链接在一起，形成流水线</li><li>流中的元素是按需计算的</li><li>流每次只能遍历一次</li></ul><h2 id="使用流"><a href="#使用流" class="headerlink" title="使用流"></a>使用流</h2><h3 id="筛选与切片"><a href="#筛选与切片" class="headerlink" title="筛选与切片"></a>筛选与切片</h3><p>用谓词筛选，filter方法，该操作接受一个谓词（一个返回boolean的函数）作为参数，并返回一个包括所有符合谓词的元素的流。<br>流还支持一个distinct方法，用来过滤重复的元素。<br>limit方法用来截断流<br>skip方法用来跳过元素</p><p><img src="https://blog-1257857643.cos.ap-beijing.myqcloud.com/blog/15402274423523.jpg" alt=""></p><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>一个非常常见的数据处理套路就是从某些对象中选择信息。<br>map方法，接受一个函数作为参数，这个函数会被应用到每个元素上，并将其映射成一个新的元素（其实就是转换，但是不会改变原序列里面的值）</p><ul><li>流的扁平化<br>flatmap 方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个流。<h3 id="查找与匹配"><a href="#查找与匹配" class="headerlink" title="查找与匹配"></a>查找与匹配</h3>anyMatch 检查谓词是否至少匹配一个元素<br>allMatch 方法检查谓词是否匹配所有元素<br>findAny 方法返回当前六中的任意元素<br>findFirst 方法查找第一个元素<h3 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h3>将流中的所有元素反复结合起来，得到一个值，这样的操作叫做归约操作（将流归约成一个值）。<br>reduce方法</li></ul><p>map和reduce的连接通常称为map-reduce模式，很容易并行化。</p><p><img src="https://blog-1257857643.cos.ap-beijing.myqcloud.com/blog/15402274550455.jpg" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何选择成长股-读书笔记</title>
      <link href="/2018/09/28/ru-he-xuan-ze-cheng-chang-gu-du-shu-bi-ji/"/>
      <url>/2018/09/28/ru-he-xuan-ze-cheng-chang-gu-du-shu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在摘录的同时会记录我的思考。</p><a id="more"></a><p>购买链接：<br><a href="https://item.jd.com/12132661.html" target="_blank" rel="noopener">《怎样选择成长股（珍藏版）》(菲利普·A·费舍)- 京东图书</a></p><h2 id="寻找优良普通股的15点原则"><a href="#寻找优良普通股的15点原则" class="headerlink" title="寻找优良普通股的15点原则"></a>寻找优良普通股的15点原则</h2><h3 id="原则1：这家公司的产品或者服务有没有充分的市场潜力，至少几年内营业额能否大幅成长？"><a href="#原则1：这家公司的产品或者服务有没有充分的市场潜力，至少几年内营业额能否大幅成长？" class="headerlink" title="原则1：这家公司的产品或者服务有没有充分的市场潜力，至少几年内营业额能否大幅成长？"></a>原则1：这家公司的产品或者服务有没有充分的市场潜力，至少几年内营业额能否大幅成长？</h3><p>那些数十年来一直保持着惊人的增长速度的公司可以分为两组，一组名叫“由于幸运而有能力”，另一组称为“由于有能力而幸运”。<br>对于这两组公司来说管理层能力的高效理性都是必不可少的，没有哪个公司仅仅由于幸运就能在长时间内持续增长。它必须拥有和继续保持商业技能的高效理想，否则就不能利用它的好运气来抵抗竞争对手的侵袭。<br>无论是哪种类型的公司，投资者必须关注管理层目前和今后是否有很强大的管理能力；如果没有的话，销售额就不会再继续增长。<br>如果公司拥有杰出的管理层，所处行业又正在接受技术的转变和发展，那么管理层有没有足够能力处理公司事务，以便在未来变革中出现的和最初设想的销售额曲线是否为同一形态，敏锐的投资者需要对此保持警惕。</p><h3 id="原则2：为了进一步提高总体销售水平，发现新的产品增长点，管理层是不是决心继续开发新产品或新工艺？"><a href="#原则2：为了进一步提高总体销售水平，发现新的产品增长点，管理层是不是决心继续开发新产品或新工艺？" class="headerlink" title="原则2：为了进一步提高总体销售水平，发现新的产品增长点，管理层是不是决心继续开发新产品或新工艺？"></a>原则2：为了进一步提高总体销售水平，发现新的产品增长点，管理层是不是决心继续开发新产品或新工艺？</h3><p>第一点原则是关于事实的问题，即对公司现有产品的潜在的销售额增长程度作出评价。<br>第二点原则是关于管理层态度的问题。公司现在是否认识到，现有市场的潜能已经几乎开发完毕，以及可能在未来的某一时间进一步发展新市场？只有在第一点原则上得到较高评价，同时以赞成的态度对待第二点原则，公司才可能获得很大的投资收益。</p><h3 id="原则3：考虑到公司规模的大小，公司在研究和发展上付出的努力是否有效？"><a href="#原则3：考虑到公司规模的大小，公司在研究和发展上付出的努力是否有效？" class="headerlink" title="原则3：考虑到公司规模的大小，公司在研究和发展上付出的努力是否有效？"></a>原则3：考虑到公司规模的大小，公司在研究和发展上付出的努力是否有效？</h3><h3 id="原则4：公司是否拥有高于平均水平的销售团队？"><a href="#原则4：公司是否拥有高于平均水平的销售团队？" class="headerlink" title="原则4：公司是否拥有高于平均水平的销售团队？"></a>原则4：公司是否拥有高于平均水平的销售团队？</h3><h3 id="原则5：公司是否具备有价值的利润率？"><a href="#原则5：公司是否具备有价值的利润率？" class="headerlink" title="原则5：公司是否具备有价值的利润率？"></a>原则5：公司是否具备有价值的利润率？</h3><p>横向对比与纵向对比结合</p><h3 id="原则6：公司正在为维持或者增加利润率而做些什么？"><a href="#原则6：公司正在为维持或者增加利润率而做些什么？" class="headerlink" title="原则6：公司正在为维持或者增加利润率而做些什么？"></a>原则6：公司正在为维持或者增加利润率而做些什么？</h3><p>买股票买的不是过去也不是现在，还是未来，我们看中的是将来的利润和利润率，如果当前公司的利润不好，那我们将要看这家公司正在做什么样的努力在改变这种低迷的颓势，如果这家公司如日中天，那我们要看这家公司在做什么保持这种势头，看这种优势有没有正在被拉大，利润和利润率有没有稳步上升。</p><h3 id="原则7：公司是否具备出色的的劳动和人事关系？"><a href="#原则7：公司是否具备出色的的劳动和人事关系？" class="headerlink" title="原则7：公司是否具备出色的的劳动和人事关系？"></a>原则7：公司是否具备出色的的劳动和人事关系？</h3><p>这个是说雇员与雇主之间的关系</p><h3 id="原则8：公司是否具有良好的行政关系？"><a href="#原则8：公司是否具有良好的行政关系？" class="headerlink" title="原则8：公司是否具有良好的行政关系？"></a>原则8：公司是否具有良好的行政关系？</h3><p>这个是说高管之间的相处问题</p><h3 id="原则9：公司的管理是否有层次？"><a href="#原则9：公司的管理是否有层次？" class="headerlink" title="原则9：公司的管理是否有层次？"></a>原则9：公司的管理是否有层次？</h3><p>如果其他因素合适的话，实际上独裁式管理的小公司可以把生意做得相当好，并且在很多年内可以成为很好的投资对象。</p><p>管理者的授权是很重要的一点。</p><h3 id="原则10：公司在成本分析和财务控制方面做得有多好？"><a href="#原则10：公司在成本分析和财务控制方面做得有多好？" class="headerlink" title="原则10：公司在成本分析和财务控制方面做得有多好？"></a>原则10：公司在成本分析和财务控制方面做得有多好？</h3><h3 id="原则11：关于竞争力的强弱，公司是否在商业的其他方面，尤其在行业内的领域为投资者提供重要的线索？"><a href="#原则11：关于竞争力的强弱，公司是否在商业的其他方面，尤其在行业内的领域为投资者提供重要的线索？" class="headerlink" title="原则11：关于竞争力的强弱，公司是否在商业的其他方面，尤其在行业内的领域为投资者提供重要的线索？"></a>原则11：关于竞争力的强弱，公司是否在商业的其他方面，尤其在行业内的领域为投资者提供重要的线索？</h3><h3 id="原则12：公司是否拥有短期或者长期的利润前景？"><a href="#原则12：公司是否拥有短期或者长期的利润前景？" class="headerlink" title="原则12：公司是否拥有短期或者长期的利润前景？"></a>原则12：公司是否拥有短期或者长期的利润前景？</h3><h3 id="原则13：在可预见的未来，公司的增长是否需要足够的股权融资，以保证更多发行在外的股份能够在很大程度上通过预期的增长来抵消现有股东的利益？"><a href="#原则13：在可预见的未来，公司的增长是否需要足够的股权融资，以保证更多发行在外的股份能够在很大程度上通过预期的增长来抵消现有股东的利益？" class="headerlink" title="原则13：在可预见的未来，公司的增长是否需要足够的股权融资，以保证更多发行在外的股份能够在很大程度上通过预期的增长来抵消现有股东的利益？"></a>原则13：在可预见的未来，公司的增长是否需要足够的股权融资，以保证更多发行在外的股份能够在很大程度上通过预期的增长来抵消现有股东的利益？</h3><h3 id="原则14：管理阶层是不是只向投资人报喜不报忧？诸事顺昌时口沫横飞，有问题或叫人失望的事情发生时，则“三缄其口”？"><a href="#原则14：管理阶层是不是只向投资人报喜不报忧？诸事顺昌时口沫横飞，有问题或叫人失望的事情发生时，则“三缄其口”？" class="headerlink" title="原则14：管理阶层是不是只向投资人报喜不报忧？诸事顺昌时口沫横飞，有问题或叫人失望的事情发生时，则“三缄其口”？"></a>原则14：管理阶层是不是只向投资人报喜不报忧？诸事顺昌时口沫横飞，有问题或叫人失望的事情发生时，则“三缄其口”？</h3><h3 id="原则15：这家公司管理层的诚信正直态度是否毋庸置疑？"><a href="#原则15：这家公司管理层的诚信正直态度是否毋庸置疑？" class="headerlink" title="原则15：这家公司管理层的诚信正直态度是否毋庸置疑？"></a>原则15：这家公司管理层的诚信正直态度是否毋庸置疑？</h3><h2 id="投资人“五不”原则"><a href="#投资人“五不”原则" class="headerlink" title="投资人“五不”原则"></a>投资人“五不”原则</h2><ol><li>不买处于创业阶段的公司。</li><li>不要因为一支好股票在“店头市场”交易，就弃之不顾。</li><li>不要因为你喜欢某公司年报的“格调”，就去买该公司的股票。</li><li>不要以为一公司的本益比（市盈率）高，便表示未来的盈余成长已大致反映在价格上。</li><li>不要锱铢必较。</li></ol><h2 id="投资人“另五不”原则"><a href="#投资人“另五不”原则" class="headerlink" title="投资人“另五不”原则"></a>投资人“另五不”原则</h2><ol><li>不要过度强调分散投资。</li><li>不要担心在战争阴影笼罩下买进股票。</li><li>不要忘了你的吉尔伯特和沙利文。</li><li>买进真正优秀的成长股时，除了考虑价格，不要忘了时机因素。</li><li>不要随波逐流。</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 投资 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见的经济学定律</title>
      <link href="/2018/09/28/chang-jian-de-jing-ji-xue-ding-lu/"/>
      <url>/2018/09/28/chang-jian-de-jing-ji-xue-ding-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="马太效应"><a href="#马太效应" class="headerlink" title="马太效应"></a>马太效应</h2><p>《新约马太福音》中有这样一个故事，一个国王远行前，交给三个仆人每人一锭银子，吩咐他们：”你们去做生意，等我回来时，再来见我。”国王回来时，第一个仆人说：”主人，你交给我们的一锭银子，我已赚了10锭。”于是国王奖励他10座城邑。第二个仆人报告说：”主人，你给我的一锭银子，我已赚了5锭。”于是国王例奖励了他5座城邑。第三个仆人报告说：”主人，你给我的一锭银子，我一直包在手巾里存着，我怕丢失，一直没有拿出来。”于是国王命令将第三个仆人的一锭银子也赏给第一个仆人，并且说：”凡是少的，就连他所有的也要夺过来。凡是多的，还要给他，叫他多多益善。”</p><a id="more"></a><p>这就是马太效应。看看我们周围，就可以发现许多马太效应的例子。朋友多的人会借助频繁的交往得到更多的朋友；缺少朋友的人会一直孤独下去。金钱方面更是如此，即使投资回报率相同，一个比别人投资多10倍的人，收益也多10倍。这是个赢家通吃的社会，善用马太效应，赢家就是你。对企业经营发展而言，马太效应则告诉我们，要想在某一个领域保持优势，就必须在此领域迅速做大。当你成为某个领域的领头羊的时候，即使投资回报率相同，你也能更轻易的获得比弱小的同行更大的收益。而若没有实力迅速在某个领域做大，就要不停地寻找新的发展领域，才能保证获得较好的回报。</p><h2 id="手表定理"><a href="#手表定理" class="headerlink" title="手表定理"></a>手表定理</h2><p>手表定理是指一个人有一只表时，可以知道几点钟，而当他同时拥有两只表时却无法确定。两只表并不能告诉一个人更准确的时间，反而会让看表的人失去对准确时间的信心。你要做的就是选择其中较信赖的一只，尽力校准它，并以此作为你的标准，听从它的指引行事。记住尼采的话：”兄弟，如果你是幸运的，你只需有一种道德而不要贪多，这样，你过桥更容易些。”如果每个人都”选择你所爱，爱你所选择”，无论成败都可以心安理得。然而，困扰很多人的是：他们被”两只表”弄得无所适从，心身交瘁，不知自己该信仰哪一个，还有人在环境、他人的压力下，违心选择了自己并不喜欢的道路，为此而郁郁终生，即使取得了受人瞩目的成就，也体会不到成功的快乐。<br>手表定理在企业经营管理方面给我们一种非常直观的启发，就是对同一个人或同一个组织的管理不能同时采用两种不同的方法，不能同时设置两个不同的目标。甚至每一个人不能由两个人来同时指挥，否则将使这个企业或这个人无所适从。手表定理所指的另一层含义在于每个人都不能同时挑选两种不同的价值观，否则，你的行为将陷于混乱。</p><h2 id="不值得定律"><a href="#不值得定律" class="headerlink" title="不值得定律"></a>不值得定律</h2><p>不值得定律最直观的表述是：不值得做的事情，就不值得做好，这个定律似乎再简单不过了，但它的重要性却时时被人们疏忘。不值得定律反映出人们的一种心理，一个人如果从事的是一份自认为不值得做的事情，往往会保持冷嘲热讽，敷衍了事的态度。不仅成功率小，而且即使成功，也不会觉得有多大的成就感。哪些事值得做呢？一般而言，这取决于三个因素。<br>1、价值观。关于价值观我们已经谈了很多，只有符合我们价值观的事，我们才会满怀热情去做。<br>2、个性和气质。一个人如果做一份与他的个性气质完全背离的工作，他是很难做好的，如一个好交往的人成了档案员，或一个害羞者不得不每天和不同的人打交道。<br>3、现实的处境。同样一份工作，在不同的处境下去做，给我们的感受也是不同的。例如，在一家大公司，如果你最初做的是打杂跑腿的工作，你很可能认为是不值得的，可是，一旦你被提升为领班或部门经理，你就不会这样认为了。<br>总结一下，值得做的工作是：符合我们的价值观，适合我们的个性与气质，并能让我们看到期望。如果你的工作不具备这三个因素，你就要考虑换一个更合适的工作，并努力做好它。因此，对个人来说，应在多种可供选择的奋斗目标及价值观中挑选一种，然后为之而奋斗。”选择你所爱的，爱你所选择的”，才可能激发我们的奋斗毅力，也才可以心安理得。而对一个企业或组织来说，则要很好地分析员工的性格特性，合理分配工作，如让成就欲较强的职工单独或牵头来完成具有一定风险和难度的工作，并在其完成时给予定时的肯定和赞扬；让依附欲较强的职工更多地参加到某个团体XXXXX同工作；让权力欲较强的职工担任一个与之能力相适应的主管。同时要加强员工对企业目标的认同感，让员工感觉到自己所做的工作是值得的，这样才能激发职工的热情。</p><h2 id="彼得原理"><a href="#彼得原理" class="headerlink" title="彼得原理"></a>彼得原理</h2><p>彼得原理是美国学者劳伦斯·彼得在对组织中人员晋升的相关现象研究后得出的一个结论：在各种组织中，由于习惯于对在某个等级上称职的人员进行晋升提拔，因而雇员总是趋向于晋升到其不称职的地位。彼得原理有时也被称为”向上爬”原理。这种现象在现实生活中无处不在：一名称职的教授被提升为大学校长后无法胜任；一个优秀的运动员被提升为主管体育的官员，而无所作为。对一个组织而言，一旦组织中的相当部分人员被推到了其不称职的级别，就会造成组织的人浮于事，效率低下，导致平庸者出人头地，发展停滞。<br>因此，这就要求改变单纯的”根据贡献决定晋升”的企业员工晋升机制，不能因某个人在某一个岗位级别上干得很出色，就推断此人一定能够胜任更高一级的职务。要建立科学、合理的人员选聘机制，客观评价每一位职工的能力和水平，将职工安排到其可以胜任的岗位。不要把岗位晋升当成对职工的主要奖励方式，应建立更有效的奖励机制，更多地以加薪、休假等方式作为奖励手段。有时将一名职工晋升到一个其无法很好发挥才能的岗位，不仅不是对职工的奖励，反而使职工无法很好发挥才能，也给企业带来损失。对个人而言，虽然我们每个人都期待着不停地升职，但不要将往上爬作为自己的惟一动力。与其在一个无法完全胜任的岗位勉力支撑、无所适从，还不如找一个自己能游刃有余的岗位好好发挥自己的专长。</p><h2 id="零和游戏原理"><a href="#零和游戏原理" class="headerlink" title="零和游戏原理"></a>零和游戏原理</h2><p>当你看到两位对弈者时，你就可以说他们正在玩”零和游戏”。因为在大多数情况下，总会有一个赢，一个输，如果我们把获胜计算为得1分，而输棋为-1分，那么，这两人得分之和就是：1+（-1）=0。这正是”零和游戏”的基本内容：游戏者有输有赢，一方所赢正是另一方所输，游戏的总成绩永远是零。零和游戏原理之所以广受关注，主要是因为人们发现在社会的方方面面都能发现与”零和游戏”类似的局面，胜利者的光荣后面往往隐藏着失败者的辛酸和苦涩。从个人到国家，从政治到经济，似乎无不验证了世界正是一个巨大的”零和游戏”场。<br>这种理论认为，世界是一个封闭的系统，财富、资源、机遇都是有限的，个别人、个别地区和个别国家财富的增加必然意味着对其他人、其他地区和国家的掠夺，这是一个”邪恶进化论”式的弱肉强食的世界。但20世纪人类在经历了两次世界大战，经济的高速增长、科技进步、全球化以及日益严重的环境污染之后，”零和游戏”观念正逐渐被”双赢”观念所取代。人们开始认识到”利己”不一定要建立在”损人”的基础上。通过有效合作，皆大欢喜的结局是可能出现的。但从”零和游戏”走向”双赢”，要求各方要有真诚合作的精神和勇气，在合作中不要耍小聪明，不要总想占别人的小便宜，要遵守游戏规则，否则”双赢”的局面就不可能出现，最终吃亏的还是自己。</p><h2 id="华盛顿合作规律"><a href="#华盛顿合作规律" class="headerlink" title="华盛顿合作规律"></a>华盛顿合作规律</h2><p>华盛顿合作规律说的是：一个人敷衍了事，两个人互相推诿，三个人则永无成事之日。多少有点类似于我们”三个和尚”的故事。人与人的合作不是人力的简单相加，而是要复杂和微妙得多。在人与人的合作中，假定每个人的能力都为1，那么10个人的合作结果就有时比10大得多，有时甚至比1还要小。因为人不是静止的动物，而更像方向各异的能量，相推动时自然事半功倍，相互抵触时则一事无成。我们传统的管理理论中，对合作研究得并不多，最直观的反映就是，大多数管理制度和行业都是致力于减少人力的无谓消耗，而非利用组织提高人的效能。换言之，不妨说管理的主要目的不是让每个人做到最好，而是避免内耗过多。21世纪将是一个合作的时代，值得庆幸的是，越来越多的人已经认识到真诚合作的重要性，正在努力学习合作。邦尼人力定律：一个人一分钟可以挖一个洞，六十个人一秒种却挖不了一个洞。合作是一个问题，如何合作也是一个问题。</p><h2 id="酒与污水定律"><a href="#酒与污水定律" class="headerlink" title="酒与污水定律"></a>酒与污水定律</h2><p>酒与污水定律是指，如果把一匙酒倒进一桶污水中，你得到的是一桶污水；如果把一匙污水倒进一桶酒中，你得到的还是一桶污水。几乎在任何组织里，都存在几个难弄的人物，他们存在的目的似乎就是为了把事情搞糟。他们到处搬弄是非，传播流言、破坏组织内部的和谐。最糟糕的是，他们像果箱里的烂苹果，如果你不及时处理，它会迅速传染，把果箱里其它苹果也弄烂，”烂苹果”的可怕之处在于它那惊人的破坏力。一个正直能干的人进入一个混乱的部门可能会被吞没，而一个人无德无才者能很快将一个高效的部门变成一盘散沙。组织系统往往是脆弱的，是建立在相互理解、妥协和容忍的基础上的，它很容易被侵害、被毒化。破坏者能力非凡的另一个重要原因在于，破坏总比建设容易。一个能工巧匠花费时日精心制作的陶瓷器，一头驴子一秒钟就能毁坏掉。如果拥有再多的能工巧匠，也不会有多少像样的工作成果。如果你的组织里有这样的一头驴子，你应该马上把它清除掉；如果你无力这样做，你就应该把它拴起来。</p><h2 id="水桶定律"><a href="#水桶定律" class="headerlink" title="水桶定律"></a>水桶定律</h2><p>水桶定律是讲，一只水桶能装多少水，完全取决于它最短的那块木板。这就是说任何一个组织都可能面临的一个共同问题，即构成组织的各个部分往往决定了整个组织的水平。构成组织的各个部分往往是优劣不齐的，而劣质部分往往又决定整个组织的水平。”水桶定律”与”酒与污水定律”不同，后者讨论的是组织中的破坏力量，而”最短的木板”却是组织中有用的一个部分，只不过比其它部分差一些，你不能把它们当成烂苹果扔掉。强弱只是相对而言的，无法消除。问题在于你容忍这种弱点到什么程度。如果它严重到成为阻碍工作的瓶颈，就不得不有所动作。<br>如果你在一个组织中，你应该：<br>1、确保你不是最薄弱的部分；<br>2、避免或减少这一薄弱环节对你成功的影响；<br>3、如果不幸，你正处在这一环节中，你还可以采取有效的方法改进，或者转职去谋另一份工作。<br>水桶定律还有最新的解释，那就是水桶是侧放着的。因此最终，你的长板决定了你的装水量。<br>比如偏科，我们经常说不好，但是历史上偏科的奇才数不胜数。</p><h2 id="蘑菇管理"><a href="#蘑菇管理" class="headerlink" title="蘑菇管理"></a>蘑菇管理</h2><p>蘑菇管理是许多组织对待初出茅庐者的一种管理方法，初学者被置于阴暗的角落（不受重视的部门，或打杂跑腿的工作），浇上一头大粪（无端的批评、指责、代人受过），任其自生自灭（得不到必要的指导和提携）。相信很多人都有这样一段”蘑菇”的经历，但这不一定是什么坏事，尤其是当一切都刚刚开始的时候，当上几天”蘑菇”，能够消除我们很多不切实际的幻想，让我们更加接近现实，看问题也更加实际，而对一个组织而言，一般地新进的人员都是一视同仁，从起薪到工作都不会有大的差别。无论你是多么优秀的人才，在刚开始的时候都只能从最简单的事情做起，”蘑菇”的经历对于成长中的年轻人来说，就像蚕茧，是羽化前必须经历的一步。所以，如何高效率地走过生命中的这一段，从中尽可能吸取经验，成熟起来，并树立良好的值得信赖的个人形象，是每个刚入社会的年轻人必须面对的课题。</p><h2 id="奥卡姆剃刀定律"><a href="#奥卡姆剃刀定律" class="headerlink" title="奥卡姆剃刀定律"></a>奥卡姆剃刀定律</h2><p>如果你认为只有焦头烂额、忙忙碌碌地工作才可能取得成功，那么，你错了。事情总是朝着复杂的方向发展，复杂会造成浪费，而效能则来自于单纯。在你做过的事情中可能绝大部分是毫无意义的，真正有效的活动只是其中的一小部分，而它们通常隐含于繁杂的事物中。找到关键的部分，去掉多余的活动，成功并不那么复杂。<br>奥卡姆剃刀：如无必要，勿增实体。<br>12世纪，英国奥卡姆的威廉对无休无止的关于”共相”、”本质”之类的争吵感到厌倦，主张唯名论，只承认确实存在的东西，认为那些空洞无物的普遍性要领都是无用的累赘，应当被无情地”剃除”。他主张，”如无必要，勿增实体。”这就是常说的”奥卡姆剃刀”。这把剃刀曾使很多人感到威胁，被认为是异端邪说，威廉本人也受到伤害。然而，这并未损害这把刀的锋利，相反，经过数百年越来越快，并早已超越了原来狭窄的领域而具有广泛的、丰富的、深刻的意义。奥卡姆剃刀定律在企业管理中可进一步深化为简单与复杂定律：把事情变复杂很简单，把事情变简单很复杂。这个定律要求，我们在处理事情时，要把握事情的主要实质，把握主流，解决最根本的问题。尤其要顺应自然，不要把事情人为地复杂化，这样才能把事情处理好。</p><h2 id="二八法则"><a href="#二八法则" class="headerlink" title="二八法则"></a>二八法则</h2><p>你所完成的工作里80%的成果，来自于你20%的付出；而80%的付出，只换来20%的成果。</p><h2 id="鲶鱼效应"><a href="#鲶鱼效应" class="headerlink" title="鲶鱼效应"></a>鲶鱼效应</h2><p>鲶鱼效应是采取一种手段或措施，刺激一些企业活跃起来投入到市场中积极参与竞争，从而激活市场中的同行业企业。其实质是一种负激励，是激活员工队伍的奥秘。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 经济学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信公众号开发中控token服务</title>
      <link href="/2018/09/28/wei-xin-gong-zhong-hao-kai-fa-zhong-kong-token-fu-wu/"/>
      <url>/2018/09/28/wei-xin-gong-zhong-hao-kai-fa-zhong-kong-token-fu-wu/</url>
      
        <content type="html"><![CDATA[<h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p>先推荐一个工具包：<br><a href="https://github.com/Wechat-Group/weixin-java-tools?utm_source=gold_browser_extension" target="_blank" rel="noopener">Wechat-Group/weixin-java-tools: 全能微信Java开发工具包，支持包括微信支付、开放平台、小程序、企业微信/企业号和公众号等的开发</a><br>以微信公众号开发为例，来说明我们所遇到的问题。<br>我们在进行微信公众号开发时，往往会拆分为多个服务，每个服务负责不同的功能，但是公众号的认证id和秘钥只有一套，这个时候如果每个服务都独自去生成access_token，就会浪费access_token的生成次数，以及会失效之前的token。这个时候需要一个独立服务来生成以及管理access_token，其余服务只需要去这个服务取token就行了。</p><a id="more"></a><p>我们在进行微信公众号开发时，微信公众号平台会给开发者ID和开发者密码，这两个东西是用来做认证的(生成access_token)。<br>我们在进行微信开发的时候，调用微信接口时，微信官方是需要认证的，如下图所示，认证的基础信息为开发者ID以及开发者密码，用这两个东西可进行认证。<br>官方是这样说的：</p><blockquote><p>access_token是公众号的全局唯一接口调用凭据，公众号调用各接口时都需使用access_token。开发者需要进行妥善保存。access_token的存储至少要保留512个字符空间。access_token的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的access_token失效。<br>公众平台的API调用所需的access_token的使用及生成方式说明：<br>1、建议公众号开发者使用中控服务器统一获取和刷新Access_token，其他业务逻辑服务器所使用的access_token均来自于该中控服务器，不应该各自去刷新，否则容易造成冲突，导致access_token覆盖而影响业务；<br>2、目前Access_token的有效期通过返回的expire_in来传达，目前是7200秒之内的值。中控服务器需要根据这个有效时间提前去刷新新access_token。在刷新过程中，中控服务器可对外继续输出的老access_token，此时公众平台后台会保证在5分钟内，新老access_token都可用，这保证了第三方业务的平滑过渡；<br>3、Access_token的有效时间可能会在未来有调整，所以中控服务器不仅需要内部定时主动刷新，还需要提供被动刷新access_token的接口，这样便于业务服务器在API调用获知access_token已超时的情况下，可以触发access_token的刷新流程。</p></blockquote><p>官方认证接口为：</p><pre><code>https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET</code></pre><h2 id="token中控服务器架构图"><a href="#token中控服务器架构图" class="headerlink" title="token中控服务器架构图"></a>token中控服务器架构图</h2><p>思路：业务服务每次在请求微信公众平台接口时，先去token中控服务取一下access_token，然后拿着这个token去微信公众平台访问其他接口，如果返回token失效，业务服务自己告诉中控服务新生成一个access_token，然后用这个新的acces_token重新去请求微信接口。</p><h2 id="如何实现token中控服务器？"><a href="#如何实现token中控服务器？" class="headerlink" title="如何实现token中控服务器？"></a>如何实现token中控服务器？</h2><p>引入jar包</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.github.binarywang&lt;/groupId&gt;    &lt;artifactId&gt;weixin-java-mp&lt;/artifactId&gt;    &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>设置一个web项目，只有这个项目有生成access_token的权限，也就是说只有这个项目有权去使用appId和appsecret调用access_token生成接口，其余服务调用这个服务生成access_token或者获取access_token。<br>中控服务提供两个接口：</p><ul><li>获取最新的access_token: 总是从redis中取出最新生成的access_token。</li><li>生成新的access_token接口：这个接口需要加锁，这把锁的失效时间应该小于5分钟，因为微信access_token生成接口，新的token生成以后，老的token会在5分钟后失效，但是如果此时又有一个人调用了生成token的服务，第一个token会立即失效。</li></ul><h2 id="封装SDK"><a href="#封装SDK" class="headerlink" title="封装SDK"></a>封装SDK</h2><p>业务方调用微信接口的流程，前面已经说清楚了，这里再重复一遍：</p><ul><li>先去中控服务取access_token。</li><li>拿着这个access_token去微信服务调用接口。</li><li>如果返回access_token失效，则进行重试。</li><li>重试的流程为：调用中控服务的生成新access_token的接口，拿着返回的新token去访问微信接口，业务方可以控制重试的次数为3次。</li></ul><p>如果每个业务方服务都把这逻辑实现一遍，那就太傻了，所以势必要对其进行封装成SDK。所幸weixin-java-tools这个jar包已经实现了大部分的功能，我们只需进行很小的改动就可以实现我们的逻辑，这里不对weixin-java-tools里面的代码做过多的解释，下面贴出实现方案：</p><pre class=" language-Java"><code class="language-Java">public class MyWxMpServiceImpl extends WxMpServiceHttpClientImpl {    private TokenClient tokenClient;    public MyWxMpServiceImpl(TokenClient tokenClient) {        this.tokenClient = tokenClient;    }    public String getAccessToken(boolean forceRefresh) throws WxErrorException {        Lock lock = this.getWxMpConfigStorage().getAccessTokenLock();        try {            lock.lock();            if (this.getWxMpConfigStorage().isAccessTokenExpired() || forceRefresh) {                String token = tokenClient.generateMpToken();                this.getWxMpConfigStorage().updateAccessToken(token, 100000);            }        } finally {            lock.unlock();        }        return this.getWxMpConfigStorage().getAccessToken();    }}</code></pre><p>新建一个类继承WxMpServiceHttpClientImpl，重写getAccessToken方法，之前的getAccessToken是去微信官方接口取access_token，这里改为token中控服务取token，其中TokenClient为对token中控服务调用的封装，这里依赖注入进来。</p><p>使用的代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> WxMpService <span class="token function">getWxMpService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        WxMpInMemoryConfigStorage configStorage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WxMpInMemoryConfigStorage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String mpToken <span class="token operator">=</span> tokenClient<span class="token punctuation">.</span><span class="token function">getMpToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        configStorage<span class="token punctuation">.</span><span class="token function">setAccessToken</span><span class="token punctuation">(</span>mpToken<span class="token punctuation">)</span><span class="token punctuation">;</span>        configStorage<span class="token punctuation">.</span><span class="token function">setExpiresTime</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span> <span class="token number">100000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        WxMpService service <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyWxMpServiceImpl</span><span class="token punctuation">(</span>tokenClient<span class="token punctuation">)</span><span class="token punctuation">;</span>        service<span class="token punctuation">.</span><span class="token function">setWxMpConfigStorage</span><span class="token punctuation">(</span>configStorage<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> service<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swagger+yapi使用笔记</title>
      <link href="/2018/09/28/swagger-yapi-shi-yong-bi-ji/"/>
      <url>/2018/09/28/swagger-yapi-shi-yong-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>写接口文档对于RD来说是件非常烦心的事情，而且随着需求迭代，人员流动，接口文档的编写一般面临以下问题：</p><ul><li>没有及时编写</li><li>没有及时更新</li><li>文档零散错落在不同的页面</li><li>因编写人的行为习惯而又显著的差异</li><li>因人员流动，交接时不太方便，在wiki中的文档或者word文档比较难自动mock<a id="more"></a></li></ul><h1 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h1><p>swagger是一个流行的API开发框架，这个框架以“开放API声明”（OpenAPI Specification，OAS）为基础，<br>对整个API的开发周期都提供了相应的解决方案，是一个非常庞大的项目（包括设计、编码和测试，几乎支持所有语言）。</p><h2 id="springfox"><a href="#springfox" class="headerlink" title="springfox"></a>springfox</h2><p>springfox的大致原理就是，在项目启动的过种中，spring上下文在初始化的过程，<br>框架自动跟据配置加载一些swagger相关的bean到当前的上下文中，并自动扫描系统中可能需要生成api文档那些类，<br>并生成相应的信息缓存起来。如果项目MVC控制层用的是springMvc那么会自动扫描所有Controller类，并生成对应的文档描述数据.</p><p>该数据是json格式，通过路径：项目地址/ v2/api-docs可以访问到该数据，然后swaggerUI根据这份数据生成相应的文档描述界面。<br>因为我们能拿到这份数据，所以我们也可以生成自己的页面.</p><h2 id="SpringBoot-结合-Swagger2"><a href="#SpringBoot-结合-Swagger2" class="headerlink" title="SpringBoot 结合 Swagger2"></a>SpringBoot 结合 Swagger2</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>springfox-swagger2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.7.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>springfox-swagger-ui<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.7.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>上面两个依赖的作用:</p><p>springfox-swagger2依然是依赖OSA规范文档，也就是一个描述API的json文件，而这个组件的功能就是帮助我们自动生成这个json文件，<br>springfox-swagger-ui就是将这个json文件解析出来，用一种更友好的方式呈现出来。</p><h3 id="配置Swagger2"><a href="#配置Swagger2" class="headerlink" title="配置Swagger2"></a>配置Swagger2</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@EnableSwagger2</span><span class="token comment" spellcheck="true">// 只针对开发环境和测试环境</span><span class="token annotation punctuation">@Profile</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token string">"development"</span><span class="token punctuation">,</span> <span class="token string">"testing"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Swagger2Config</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> Docket <span class="token function">createRestApi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Docket</span><span class="token punctuation">(</span>DocumentationType<span class="token punctuation">.</span>SWAGGER_2<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">apiInfo</span><span class="token punctuation">(</span><span class="token function">apiInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">apis</span><span class="token punctuation">(</span>RequestHandlerSelectors<span class="token punctuation">.</span><span class="token function">basePackage</span><span class="token punctuation">(</span><span class="token string">"com.hetao101.channel.web"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 监听的package名字</span>                <span class="token punctuation">.</span><span class="token function">paths</span><span class="token punctuation">(</span>PathSelectors<span class="token punctuation">.</span><span class="token function">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> ApiInfo <span class="token function">apiInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ApiInfoBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">title</span><span class="token punctuation">(</span><span class="token string">"市场-渠道管理-接口api文档"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 当前项目接口文档的简单描述</span>                <span class="token punctuation">.</span><span class="token function">version</span><span class="token punctuation">(</span><span class="token string">"1.0"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 版本号</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="Swagger常用注解说明"><a href="#Swagger常用注解说明" class="headerlink" title="Swagger常用注解说明"></a>Swagger常用注解说明</h3><p>@Api<br>用在类上，说明该类的作用。</p><pre class=" language-Java"><code class="language-Java">@Api(value = "Message-API", produces = "application/json")</code></pre><p>@Api注解上有一个tags属性，用于进行接口分组分类</p><p>@ApiOperation<br>是上面@Api注解的附属注解，用在方法上,说明方法的作用，每一个url资源的定义。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"消息列表"</span><span class="token punctuation">,</span> notes <span class="token operator">=</span> <span class="token string">"消息列表"</span><span class="token punctuation">)</span></code></pre><p>@ApiModel<br>用在POJO上，用于描述一个Bean的信息，可以用于是请求参数对象类(Application/Json)，也可以用于返回对象类上。<br>@ApiModelProperty<br>是上面的@ApiModel注解的附属注解，用于描述具体的属性。</p><pre class=" language-Java"><code class="language-Java">@ApiModel(value="user对象",description="用户对象user")public class User implements Serializable{    @ApiModelProperty(value="用户名",name="username",example="xingguo",required=true)    private String username;}</code></pre><p>@ApiParam<br>用于请求属性上，一般用于路径参数或者form表单请求</p><pre class=" language-Java"><code class="language-Java">@ApiParam(value = "邮箱或用户名", required = true) @RequestParam("value") String value</code></pre><h1 id="yapi"><a href="#yapi" class="headerlink" title="yapi"></a>yapi</h1><p><img src="http://ody8qw44c.bkt.clouddn.com/2018-09-28-15381050024055.jpg" alt=""><br><a href="https://github.com/YMFE/yapi" target="_blank" rel="noopener">YMFE/yapi: YApi 是一个可本地部署的、打通前后端及QA的、可视化的接口管理平台</a><br>yapi是支持Swagger导入的，上面的教程中，我们在Spring boot项目中引入了swagger-ui jar包，轻而易举生成了Web形式的文档，但是JSON文件怎么生成呢？<br>原来 /v2/api-docs 路径就是json文件的内容，我们可以用wget命令下载json文件,示例如下：</p><pre class=" language-shell"><code class="language-shell">wget -O swagger.json http://127.0.0.1:8001/v2/api-docs</code></pre><p>其中 <code>http://127.0.0.1:8001</code>是我本地项目的访问方式，这样会得到接口的JSON文件–swagger.json。</p><h2 id="swagger文档导入yapi"><a href="#swagger文档导入yapi" class="headerlink" title="swagger文档导入yapi"></a>swagger文档导入yapi</h2><p>有了swagger API文档文件以后就可以导入Yapi了，官方提供了两种方式：</p><h3 id="Web控制台导入"><a href="#Web控制台导入" class="headerlink" title="Web控制台导入"></a>Web控制台导入</h3><p><img src="http://ody8qw44c.bkt.clouddn.com/2018-09-28-15381065558095.jpg" alt=""></p><h3 id="命令行导入"><a href="#命令行导入" class="headerlink" title="命令行导入"></a>命令行导入</h3><p>第一步，安装yapi工具</p><pre class=" language-shell"><code class="language-shell">npm install -g yapi-cli</code></pre><p>第二步，在任意一个目录下新建配置文件 yapi-import.json，内容如下：</p><pre class=" language-JSON"><code class="language-JSON">{  "type": "swagger",  "token": "17fba0027f300248b804",  "file": "swagger.json",  "merge": "normal",  "server": "http://yapi.local.qunar.com:3000"}</code></pre><p>type 是数据数据方式，目前官方只支持 swagger</p><p>token 是项目 token，在 项目设置 -&gt; token 设置获取</p><p>file 是 swagger 接口文档文件，可使用绝对路径或 url</p><p>merge 有三种导入方式(v1.3.23+支持) normal, good, mergin<br>普通模式(normal)：不导入已存在的接口；<br>智能合并(good)：已存在的接口，将合并返回数据的 response，适用于导入了 swagger 数据，保留对数据结构的改动；<br>完全覆盖(mergin)：不保留旧数据，完全使用新数据，适用于接口定义完全交给后端定义， 默认为 normal</p><p>server 是 yapi 服务器地址</p><p>第三步，在新建配置文件的当前目录，执行下面指令</p><pre class=" language-shell"><code class="language-shell">yapi import</code></pre><h1 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h1><p><a href="https://legacy.gitbook.com/book/huangwenchao/swagger/details" target="_blank" rel="noopener">Swagger从入门到精通 · GitBook (Legacy)</a><br><a href="https://blog.csdn.net/itguangit/article/details/78978296" target="_blank" rel="noopener">一篇文章带你搞懂 SpringBoot与Swagger整合 - CSDN博客</a><br><a href="https://yapi.ymfe.org/documents/data.html#swagger-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5" target="_blank" rel="noopener">Yapi-数据导入-教程</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> yapi </tag>
            
            <tag> swagger </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
